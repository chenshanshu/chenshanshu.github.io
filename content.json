{"meta":{"title":"MyBlog","subtitle":"","description":"前端开发 javascript css html 样式","author":"chenss","url":"https://chenshanshu.github.io/2020/06/15/hello-world","root":"/"},"pages":[{"title":"categories","date":"2022-01-10T02:31:12.000Z","updated":"2022-08-30T08:02:47.377Z","comments":true,"path":"categories/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-30T08:06:03.912Z","updated":"2022-08-30T08:06:03.912Z","comments":true,"path":"about/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-10T02:31:55.000Z","updated":"2022-08-30T08:03:26.557Z","comments":true,"path":"tags/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/index.html","excerpt":"","text":""},{"title":"mylist","date":"2022-08-30T08:04:54.237Z","updated":"2022-08-30T08:04:54.237Z","comments":true,"path":"mylist/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-22T06:44:33.571Z","updated":"2022-09-22T06:44:33.571Z","comments":true,"path":"examples/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/examples/index.html","excerpt":"","text":"democanvas 文件名 链接 图片裁剪1 地址 图片裁剪2 地址 捉小猫 地址 飞机大战 地址 数字游戏 地址"}],"posts":[{"title":"前端分享-2022-12-15","slug":"前端分享-2022-12-15","date":"2022-12-14T03:35:14.000Z","updated":"2022-12-15T05:44:59.285Z","comments":true,"path":"2022/12/14/前端分享-2022-12-15/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/12/14/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-12-15/","excerpt":"console.log在写node程序时，使用 console 打印，如果对象里面还是对象时不会展开, 会打印成 [Object] [Array] 如果打印的内容比较长会超过缓冲区大小， terminal 里会显示不全这些情况下可以使用 debugger 搭配 logpoint","text":"console.log在写node程序时，使用 console 打印，如果对象里面还是对象时不会展开, 会打印成 [Object] [Array] 如果打印的内容比较长会超过缓冲区大小， terminal 里会显示不全这些情况下可以使用 debugger 搭配 logpoint package.json mainmain 指的是 npm package 的入口文件，是最古老且最常用的入口文件 module随着 ESM 和打包工具的发展, 许多 package 会打包成多种格式的包如果使用 import 对该库进行导入，则先寻找 module 字段引入，否则引入 main 字段。 exports不在 exports 字段中的模块，即使直接访问路径，也无法引用！示例： 123456789101112131415161718&quot;exports&quot;:&#123; &quot;node&quot;:&#123; &quot;dev&quot;: &quot;...&quot;, &quot;production&quot;: &quot;...&quot; &#125;, &quot;browser&quot;:&#123; &quot;dev&quot;: &quot;...&quot;, &quot;production&quot;: &quot;...&quot; &#125;&#125;// 或者下面这种&quot;exports&quot;:&#123; &quot;.&quot;:&#123; &quot;import&quot;: &quot;...&quot;, &quot;require&quot;: &quot;...&quot; &#125;&#125; scripts定义在 scripts 中的命令，我们通过 npm run &lt;command&gt; 就可以执行。 npm run &lt;command&gt; 是 npm run-script &lt;command&gt; 的简写test 、 start 、 restart 、 stop 这几个命令执行时可以不加 run ；env 是一个内置的命令, npm run env 可以获取到脚本运行时的所有环境变量。 rollup在开发一个包想使用chalk时，遇到的一个问题。","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"快速上手Rollup","slug":"快速上手Rollup","date":"2022-11-28T08:17:41.000Z","updated":"2022-12-15T02:47:01.024Z","comments":true,"path":"2022/11/28/快速上手Rollup/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/28/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRollup/","excerpt":"什么是 Rollup Rollup 是一个 JavaScript 模块打包工具，可以将多个小的代码片段编译为完整的库和应用。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 Javascript 中的模块标准。新的 ES 模块可以让你自由、无缝地按需使用你最喜爱的库中那些有用的单个函数。这一特性在未来将随处可用，但 Rollup 让你现在就可以，想用就用。 为什么是 Rollup 这里简单对webpack、gulp、Rollup做一个比较： gulp 是一个构建工具，主要完成代码压缩、编译转化, 可以替代手工实现自动化工作 Webpack 支持 HMR ，有更完整的插件库，适合用于前端工程化开发 Rollup 更小巧，仅仅是一款 ESM 打包器，支持 Tree-shaking 如果您的代码库是基于ES6或者TS，且希望其他人安装后可以直接使用，这个时候就可以使用Rollup 快速开始Rollup 可以通过两种方式使用：使用命令行方式，或者 JavaScript API 方式 直接命令行运行用于浏览器: 12# 编译为一个在 &lt;script&gt; 标签中可用的自运行函数 (&#x27;iife&#x27;)rollup main.js --file bundle.js --format iife 用于 Node.js : 12# 编译为 CommonJS 模块 (&#x27;cjs&#x27;)rollup main.js --file bundle.js --format cjs 同时用于浏览器和 Node.js： 12# 需要为 UMD 格式的包指定一个名称rollup main.js --file bundle.js --format umd --name &quot;myBundle&quot; -f ：是 --format 的缩写。-o ：指定了输出的路径。-c ：指定rollup的配置文件。-w ：监听源文件是否有改动，如果有改动，重新打包。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码： 12345678export default &#123; input: [&quot;./src/index.js&quot;], output: &#123; file: &quot;./dist/bundle.js&quot;, format: &quot;umd&quot;, name: &quot;experience&quot;, &#125;,&#125;;","text":"什么是 Rollup Rollup 是一个 JavaScript 模块打包工具，可以将多个小的代码片段编译为完整的库和应用。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 Javascript 中的模块标准。新的 ES 模块可以让你自由、无缝地按需使用你最喜爱的库中那些有用的单个函数。这一特性在未来将随处可用，但 Rollup 让你现在就可以，想用就用。 为什么是 Rollup 这里简单对webpack、gulp、Rollup做一个比较： gulp 是一个构建工具，主要完成代码压缩、编译转化, 可以替代手工实现自动化工作 Webpack 支持 HMR ，有更完整的插件库，适合用于前端工程化开发 Rollup 更小巧，仅仅是一款 ESM 打包器，支持 Tree-shaking 如果您的代码库是基于ES6或者TS，且希望其他人安装后可以直接使用，这个时候就可以使用Rollup 快速开始Rollup 可以通过两种方式使用：使用命令行方式，或者 JavaScript API 方式 直接命令行运行用于浏览器: 12# 编译为一个在 &lt;script&gt; 标签中可用的自运行函数 (&#x27;iife&#x27;)rollup main.js --file bundle.js --format iife 用于 Node.js : 12# 编译为 CommonJS 模块 (&#x27;cjs&#x27;)rollup main.js --file bundle.js --format cjs 同时用于浏览器和 Node.js： 12# 需要为 UMD 格式的包指定一个名称rollup main.js --file bundle.js --format umd --name &quot;myBundle&quot; -f ：是 --format 的缩写。-o ：指定了输出的路径。-c ：指定rollup的配置文件。-w ：监听源文件是否有改动，如果有改动，重新打包。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码： 12345678export default &#123; input: [&quot;./src/index.js&quot;], output: &#123; file: &quot;./dist/bundle.js&quot;, format: &quot;umd&quot;, name: &quot;experience&quot;, &#125;,&#125;; 输出的6种格式iife , amd , umd , cjs , esm , system 模块化方案 描述 优点 缺点 iife 是前端模块化早期的产物，它的核心思路是：1、构建一个匿名函数2、立即执行这个函数，外部的依赖通过入参形式传入3、返回该模块的输出 不影响代码体积 1、输出的变量可能影响全局变量，引入依赖包时依赖全局变量2、需要使用者自行维护 script 标签加载顺序 cjs 为了解决 node.js 在模块化上的缺失，2009年 CommonJS 规范首次被提出 完善的模块化方案 只能在 node.js 环境使用 amd 2011年， amdjs-api 被正式提出 1、解决了 IIFE 的缺点2、一套完备的浏览器里 js 文件模块化方案 代码组织形式别扭，可读性差 umd 兼容了 amd 和 CommonJS 抹平了一个包在 AMD 和 CommonJS 里的差异 会产生兼容代码 esm javascript 模块化官方标准格式。 可读性高 部分浏览器不兼容 Rollup 中常用的几个插件 resolve: 将我们编写的源码与依赖的第三方库进行合并 1npm i -D @rollup/plugin-node-resolve 修改 rollup.config.js : 1234567import resolve from &quot;@rollup/plugin-node-resolve&quot;;export default&#123;...plugins: [resolve()],external: [],&#125; commonjs: 使得rollup.js编译支持npm模块和CommonJS模块方式的插件：@rollup/plugin-commonjs babel: 将ES6语法转成ES5 json","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"Rollup","slug":"Rollup","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Rollup/"}]},{"title":"编写npm包遇到的问题","slug":"编写npm包遇到的问题","date":"2022-11-16T09:00:31.000Z","updated":"2022-11-17T06:09:53.081Z","comments":true,"path":"2022/11/16/编写npm包遇到的问题/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/16/%E7%BC%96%E5%86%99npm%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"前言最近在编写一个npm包时遇到几个问题，记录下来防止下次卡在同一个地方，后续遇到的坑会继续整理 一、CJS和ESM不能同时使用 问题描述：在编写一个node环境的NPM包时，引用了一个ESM模块机制的包 Node对ESM的支持Node 13.2.0 起开始正式支持ES Modules特性，使用方法如下： 在package.json中，增加&quot;type&quot;:&quot;module&quot; 将文件.js后缀修改为.mjs 上面两种方法二选一，如果不配置，则会抛出警告：Warning: To load an ES module, set &quot;type&quot;: &quot;module&quot; in the package.json or use the .mjs extension.","text":"前言最近在编写一个npm包时遇到几个问题，记录下来防止下次卡在同一个地方，后续遇到的坑会继续整理 一、CJS和ESM不能同时使用 问题描述：在编写一个node环境的NPM包时，引用了一个ESM模块机制的包 Node对ESM的支持Node 13.2.0 起开始正式支持ES Modules特性，使用方法如下： 在package.json中，增加&quot;type&quot;:&quot;module&quot; 将文件.js后缀修改为.mjs 上面两种方法二选一，如果不配置，则会抛出警告：Warning: To load an ES module, set &quot;type&quot;: &quot;module&quot; in the package.json or use the .mjs extension. 如何发布一个支持 Tree Shaking 机制的 npm 包？pkg.main 字段指向的应该是编译后生成的 ES5 版本的代码。pkg.module 字段要指向的应该是一个基于 ES6 模块规范的使用ES5语法书写的模块。要构建一个满足 pkg.module 字段要求的包其实很简单。如果你是使用 Rollup 打包代码， 那么只需要把 output 的格式设置为 es 就可以啦。","categories":[{"name":"问题","slug":"问题","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/npm/"}]},{"title":"前端分享-2022-11-03","slug":"前端分享-2022-11-03","date":"2022-11-03T07:50:11.000Z","updated":"2022-11-28T08:21:01.534Z","comments":true,"path":"2022/11/03/前端分享-2022-11-03/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/03/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-11-03/","excerpt":"遇到的几个问题 时间戳转换日期出现不准确情况123456let t = 577292400000console.log(new Date(t).toLocaleDateString()) //1988/4/18t = t - 24 * 60 * 60 * 1000console.log(new Date(t).toLocaleDateString()) //1988/4/16let t2 = new Date(&#x27;1988/4/17&#x27;).getTime() //577209600000t - t2 === 23 * 60 * 60 * 1000 safari中定位1234.box&#123; position: relative; top: 50%; &#125; 发现用百分比不生效，修改为具体高度后解决","text":"遇到的几个问题 时间戳转换日期出现不准确情况123456let t = 577292400000console.log(new Date(t).toLocaleDateString()) //1988/4/18t = t - 24 * 60 * 60 * 1000console.log(new Date(t).toLocaleDateString()) //1988/4/16let t2 = new Date(&#x27;1988/4/17&#x27;).getTime() //577209600000t - t2 === 23 * 60 * 60 * 1000 safari中定位1234.box&#123; position: relative; top: 50%; &#125; 发现用百分比不生效，修改为具体高度后解决","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"js数组去重","slug":"js数组去重","date":"2022-10-25T01:50:18.000Z","updated":"2022-11-02T08:08:09.345Z","comments":true,"path":"2022/10/25/js数组去重/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/10/25/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"普通数组（元素为基本类型的）1. 使用Set123Array.from(new Set(arr));[...new Set(arr)];//两种任选一个 2. 新建数组加indexOf123456const newArr = []arr.forEach(item =&gt; &#123; if (newArr.indexOf(item) &lt; 0) &#123; newArr.push(item) &#125;&#125;) 3. 类似前一种，使用includes()判断123456const newArr = []arr.forEach(item =&gt; &#123; if (!newArr.includes(item)) &#123; newArr.push(item) &#125;&#125;) 4. 变量在原数组中出现的第一个位置123456const newArr = []arr.forEach((item, index) =&gt; &#123; if (arr.indexOf(item) === index) &#123; newArr.push(item) &#125;&#125;) 5. filter123const newArr = arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index&#125;) 6. 利用两层循环+数组的splice方法(不推荐)","text":"普通数组（元素为基本类型的）1. 使用Set123Array.from(new Set(arr));[...new Set(arr)];//两种任选一个 2. 新建数组加indexOf123456const newArr = []arr.forEach(item =&gt; &#123; if (newArr.indexOf(item) &lt; 0) &#123; newArr.push(item) &#125;&#125;) 3. 类似前一种，使用includes()判断123456const newArr = []arr.forEach(item =&gt; &#123; if (!newArr.includes(item)) &#123; newArr.push(item) &#125;&#125;) 4. 变量在原数组中出现的第一个位置123456const newArr = []arr.forEach((item, index) =&gt; &#123; if (arr.indexOf(item) === index) &#123; newArr.push(item) &#125;&#125;) 5. filter123const newArr = arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index&#125;) 6. 利用两层循环+数组的splice方法(不推荐) 对象数组的去重12345const arr = [&#123; key: &#x27;key1&#x27;&#125;, &#123; key: &#x27;key2&#x27;&#125;] 1. 利用对象属性不能相同12345678const newArr = []const obj = &#123;&#125;arr.forEach((item, index) =&gt; &#123; if (!obj.hasOwnProperty(item[&#x27;key&#x27;])) &#123; newArr.push(item) obj[item[&#x27;key&#x27;]] = true &#125;&#125;) 2. 使用Map12345678const newArr = []const map = new Map()arr.forEach((item, index) =&gt; &#123; if (!map.has(item[&#x27;key&#x27;])) &#123; newArr.push(item) map.set(item[&#x27;key&#x27;], true) &#125;&#125;)","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"编写一个cli","slug":"编写一个cli","date":"2022-10-13T06:54:02.000Z","updated":"2022-11-03T02:01:50.081Z","comments":true,"path":"2022/10/13/编写一个cli/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/10/13/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAcli/","excerpt":"cliCommand Line Interface – 命令行界面为什么要写这个东西？ 可以自己开发一个脚手架 可以更灵活地更改配置 脚手架执行步骤： 在终端输入 vue create vue-test-app 终端解析出 vue命令 终端环境变量中找到vue命令 终端利用node执行vue.js vue.js解析command / options vue.js执行command 执行完毕，退出执行 为什么全局安装完vue-cli 会有一个vue命令？ 在package.json中配置了bin目录，node会在bin目录下配置一个对应的软连接 实现流程1. 初始化一个项目123&gt; mkdir test-cli&gt; cd test-cli&gt; npm init [-y] //创建一个package.json(默认初始值) 2. 注册执行命令 新建目录bin 在这个目录新建文件cli.js 修改package.json, 来告诉npm执行文件位置 1234# package.json&quot;bin&quot;: &#123; &quot;test&quot;: &quot;./bin/cli.js&quot;&#125; 编辑cli.js 123#! /usr/bin/env nodeconsole.log(&#x27;hello world!&#x27;) 3. 模拟执行发布上线再安装测试比较繁琐，且导致版本号膨胀，可以在本地使用 npm link(npm ln) 创建软链接到全局执行 npm link ，会在node的根目录下生成三个文件 12345├──node│ ├──node_modules│ ├──test│ ├──test.cmd│ └──test.ps1 在命令行中输入 test , 会看到打印信息","text":"cliCommand Line Interface – 命令行界面为什么要写这个东西？ 可以自己开发一个脚手架 可以更灵活地更改配置 脚手架执行步骤： 在终端输入 vue create vue-test-app 终端解析出 vue命令 终端环境变量中找到vue命令 终端利用node执行vue.js vue.js解析command / options vue.js执行command 执行完毕，退出执行 为什么全局安装完vue-cli 会有一个vue命令？ 在package.json中配置了bin目录，node会在bin目录下配置一个对应的软连接 实现流程1. 初始化一个项目123&gt; mkdir test-cli&gt; cd test-cli&gt; npm init [-y] //创建一个package.json(默认初始值) 2. 注册执行命令 新建目录bin 在这个目录新建文件cli.js 修改package.json, 来告诉npm执行文件位置 1234# package.json&quot;bin&quot;: &#123; &quot;test&quot;: &quot;./bin/cli.js&quot;&#125; 编辑cli.js 123#! /usr/bin/env nodeconsole.log(&#x27;hello world!&#x27;) 3. 模拟执行发布上线再安装测试比较繁琐，且导致版本号膨胀，可以在本地使用 npm link(npm ln) 创建软链接到全局执行 npm link ，会在node的根目录下生成三个文件 12345├──node│ ├──node_modules│ ├──test│ ├──test.cmd│ └──test.ps1 在命令行中输入 test , 会看到打印信息 主程序编写1. 需要使用的核心库 commander.js: 用来解析各种命令 inquirer.js：命令行交互，创建一个选项列表让用户选择 downloadgitRepo: 下载 chalk: 文字添加颜色，美化输出 2. process.argv可以获取到用户在命令行输入的内容 cli.js文件中添加console.log(process.argv) 执行test aaa, 打印如下结果 12345[ &#x27;D:\\\\node\\\\node.exe&#x27;, &#x27;D:\\\\node\\\\node_modules\\\\chen-cli\\\\bin\\\\cli.js&#x27;, &#x27;aaa&#x27;] 3. 修改 cli.js123456789101112131415161718#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const path = require(&#x27;path&#x27;)program .command(&#x27;create &lt;app-name&gt;&#x27;) .description(&#x27;create a new project&#x27;) .option(&#x27;-f --force&#x27;, &#x27;overwrite target directory if it exist&#x27;) .action((name, options) =&gt; &#123; console.log(&#x27;name:&#x27;, name, &#x27;options&#x27;, options) &#125;)program .version(`v$&#123;require(&#x27;../package.json&#x27;).version&#125;`) .usage(&#x27;&lt;command&gt; [option]&#x27;)program.parse(process.argv) 执行test -V会打印package.json中的版本号 执行test create app -f会触发对应的action方法 4. 编写具体的方法 新建目录lib 在这个目录新建文件create.js 获取项目模板有两种方式，一种是git克隆，另一种内置在项目里 1234567891011121314151617181920212223242526272829303132333435363738394041424344const util = require(&#x27;util&#x27;)const path = require(&#x27;path&#x27;)const downloadgitRepo = require(&#x27;download-git-repo&#x27;)const fs = require(&quot;fs-extra&quot;)const cp = require(&#x27;child_process&#x27;)// const chalk = require(&#x27;chalk&#x27;)async function wrapLoading(fn, message, params) &#123; console.log(message) if (params.type === &#x27;static&#x27;) &#123; // 1:使用内置模板 const targetDir = params.targetDir const templateDir = path.resolve(__dirname, &#x27;../template&#x27;) try &#123; fs.mkdirSync(targetDir) fs.copySync(templateDir, targetDir) &#125; catch (e) &#123; console.log(&#x27;创建失败&#x27;, e) &#125; &#125; else if (params.type === &#x27;git&#x27;) &#123; // 2:git try &#123; // await fn(params.gitUrl, params.targetDir) cp.execSync(`git clone $&#123;params.gitUrl&#125; $&#123;params.targetName&#125;`) &#125; catch (e) &#123; console.log(&#x27;创建失败&#x27;, e) &#125; &#125;&#125;class Generator &#123; constructor() &#123; this.downloadgitRepo = util.promisify(downloadgitRepo) &#125; async download(params) &#123; await wrapLoading( this.downloadgitRepo, &#x27;waiting download template&#x27;, params ) // console.log(`\\r\\nSuccessfully create project $&#123;chalk.cyan(this.name)&#125;`) // console.log(`\\r\\n cd $&#123;chalk.cyan(this.name)&#125;`) // console.log(&#x27;npm run dev\\r\\n&#x27;) &#125;&#125;module.exports = Generator npm发布1. 注册npm账号如果没有账号先去官网注册一个访问npm官网; 注册一个账号 2. 发布域级包为了避免命名冲突 npm官网点击头像，选择下拉框中的Add Organization 添加后得到了名称name 下次初始化时npm init --scope=name 如果是开发完的包, 直接修改package.json中的name属性 1&quot;name&quot;: &quot;@name/test-cli&quot;, 3. 还原仓库地址使用了淘宝镜像的要修改回官方地址 1npm config set registry https://registry.npmjs.org/ 4. 上传发布 npm whoami可以看登录信息 未登录的使用npm login npm publish发布 如果返回E402错误，使用npm publish --access public 发布成功后可以安装使用 5. 修改提交每次修改后要改版本号，不能提交相同的； 主版本号(major)：当你做了不兼容的API修改 次版本号(minor)：当你做了向下兼容的功能性新增 修订号(patch)：当你做了向下兼容的问题修正 12npm version patchnpm publish 另外还有先行版本；当要发行大版本或者核心功能时，不能保证这个版本完全正常，就要先发一个先行版本常见的先行版本号有： alpha：不稳定版本，一般而言，该版本的Bug较多，需要继续修改，是测试版本 beta：基本稳定，相对于Alpha版已经有了很大的进步，消除了严重错误 rc：和正式版基本相同，基本上不存在导致错误的Bug release：最终版本 6. 版本撤回 npm unpublish [pkg]@[version]","categories":[{"name":"工具","slug":"工具","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"cli","slug":"cli","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/cli/"},{"name":"node","slug":"node","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/node/"}]},{"title":"前端分享-2022-09-15","slug":"前端分享-2022-09-15","date":"2022-09-15T07:06:48.000Z","updated":"2022-09-16T02:47:38.400Z","comments":true,"path":"2022/09/15/前端分享-2022-09-15/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/09/15/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-09-15/","excerpt":"node版本管理工具nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰mac环境推荐使用n 图片裁剪地址 js大数字问题超出 2 的 53 次方之后，一个数就不精确了 123456Number.MAX_SAFE_INTEGER === 9007199254740991handleResData(str)&#123; str = str.replace(/[:]([0-9]&#123;18,&#125;)[,]?/g,`:&quot;$1&quot;,`); return JSON.parse(str)&#125;","text":"node版本管理工具nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰mac环境推荐使用n 图片裁剪地址 js大数字问题超出 2 的 53 次方之后，一个数就不精确了 123456Number.MAX_SAFE_INTEGER === 9007199254740991handleResData(str)&#123; str = str.replace(/[:]([0-9]&#123;18,&#125;)[,]?/g,`:&quot;$1&quot;,`); return JSON.parse(str)&#125;","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"}]},{"title":"前端分享-2022-07-28","slug":"前端分享-2022-07-28","date":"2022-07-28T07:13:49.000Z","updated":"2022-08-30T08:29:02.427Z","comments":true,"path":"2022/07/28/前端分享-2022-07-28/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/07/28/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-07-28/","excerpt":"NUXTNUXT 简介 Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 SSR是英文server side render的缩写，即服务端描画。 NUXT 解决了什么问题 SPA随着工程不断变大，打包文件不断增长，页面的整体刷新加载速度慢。 为了SEO NUXT 会带来的问题 更长的链路，之前是浏览器+nginx+后台服务，而现在就变成浏览器+nginx+nodejs+后台服务。 nodejs中的阻塞型请求，容易成为性能的瓶颈。 一套api，要考虑前后端的兼容性。","text":"NUXTNUXT 简介 Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 SSR是英文server side render的缩写，即服务端描画。 NUXT 解决了什么问题 SPA随着工程不断变大，打包文件不断增长，页面的整体刷新加载速度慢。 为了SEO NUXT 会带来的问题 更长的链路，之前是浏览器+nginx+后台服务，而现在就变成浏览器+nginx+nodejs+后台服务。 nodejs中的阻塞型请求，容易成为性能的瓶颈。 一套api，要考虑前后端的兼容性。 VUE3VUE3介绍","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"}]},{"title":"快速上手vue3","slug":"快速上手vue3","date":"2022-07-15T08:14:14.000Z","updated":"2022-11-28T08:21:25.386Z","comments":true,"path":"2022/07/15/快速上手vue3/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/07/15/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bvue3/","excerpt":"vue3的优势 Vue3使用TS重构了项目，获得更好的类型支持。 TypeScript 增加了代码的可读性和可维护性 引入了接口、类、继承的编程思想 ts是js的超集，支持所有es6语法 ts在编译时会有错误提示，js在运行时才能暴露错误（大型应用测试很难覆盖到全部代码） ts是强类型语言，可读性强，方便迭代 (不是「强类型」，是「静态类型检查」的「弱类型」) TypeScript 的类型系统是图灵完备的，可以定义从简单到复杂的几乎一切类型 新建小程序项目可以发现默认的模板是ts 重构了响应式系统 更好的Tree shaking Tree-shaking其实就是把无用的模块进行“剪枝”，很多没有用到的 API 就不会打包到最后的包里 比Vue 2更强 重写了虚拟Dom的实现 编译模板的优化。 更高效的组件初始化。 update性能提高1.3~2倍。 SSR速度提高了2~3倍。 Composition API 暴露自定义渲染API Composition API Options API与Composition API对比 Options API 伪代码 Composition API 伪代码 export default &#123; name: ..., data() &#123; return &#123; // 功能A // 功能B ... &#125; &#125;, methods: &#123; // 功能A // 功能B ... &#125;, created() &#123; // 功能A // 功能B ... &#125; &#125; import &#123; defineComponent &#125; from 'vue' export default defineComponent(&#123; setup(props,context)&#123; // 功能A // 功能B ... return&#123; ... &#125; &#125; &#125;) Composition API这里仅介绍setup语法糖用法，函数式写法请参考vue3文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt; script setup &gt; import &#123; ref, reactive, defineExpose, defineProps, defineEmits, onMounted, nextTick, computed， watch &#125; from &#x27;vue&#x27;import &#123; useStore&#125; from &#x27;vuex&#x27;import myLogo from &#x27;@/components/myLogo&#x27; //引入的组件不需要再注册const store = useStore() //获取vuex商店const userInfo = computed(() =&gt; store.state.userInfo)const props = defineProps(&#123; item: &#123; type: Object, default: null &#125;&#125;)onMounted(() =&gt; &#123; modelA()&#125;)const list = ref(null) // 1. ref底层还是调用的reactiveconst element = ref(null) // 2. ref的另一个用法，添加到元素的ref属性，将元素赋值给这个变量const list2 = reactive(&#123; a: 1, b: 2&#125;)function modelA() &#123; request(&#123; ... &#125;).then(res =&gt; &#123; // 3. js中需要通过.value才能操作数据，template模板中可以直接访问 list.value = res.data; list2.a = res.data.no; // 4. 不能重新给list2赋值，否则会断开响应式 // list2 = &#123; // ... // &#125; &#125;).catch(err =&gt; &#123; &#125;)&#125;// 5. 给父组件传参方式const emit = defineEmits([&#x27;choose&#x27;])function handleClick() &#123; emit(&#x27;choose&#x27;, [arg])&#125;// 6. setup中定义的变量、方法在外部组件不可见，通过defineExpose暴露出去defineExpose(&#123; modelA &#125;) &lt; /script&gt;","text":"vue3的优势 Vue3使用TS重构了项目，获得更好的类型支持。 TypeScript 增加了代码的可读性和可维护性 引入了接口、类、继承的编程思想 ts是js的超集，支持所有es6语法 ts在编译时会有错误提示，js在运行时才能暴露错误（大型应用测试很难覆盖到全部代码） ts是强类型语言，可读性强，方便迭代 (不是「强类型」，是「静态类型检查」的「弱类型」) TypeScript 的类型系统是图灵完备的，可以定义从简单到复杂的几乎一切类型 新建小程序项目可以发现默认的模板是ts 重构了响应式系统 更好的Tree shaking Tree-shaking其实就是把无用的模块进行“剪枝”，很多没有用到的 API 就不会打包到最后的包里 比Vue 2更强 重写了虚拟Dom的实现 编译模板的优化。 更高效的组件初始化。 update性能提高1.3~2倍。 SSR速度提高了2~3倍。 Composition API 暴露自定义渲染API Composition API Options API与Composition API对比 Options API 伪代码 Composition API 伪代码 export default &#123; name: ..., data() &#123; return &#123; // 功能A // 功能B ... &#125; &#125;, methods: &#123; // 功能A // 功能B ... &#125;, created() &#123; // 功能A // 功能B ... &#125; &#125; import &#123; defineComponent &#125; from 'vue' export default defineComponent(&#123; setup(props,context)&#123; // 功能A // 功能B ... return&#123; ... &#125; &#125; &#125;) Composition API这里仅介绍setup语法糖用法，函数式写法请参考vue3文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt; script setup &gt; import &#123; ref, reactive, defineExpose, defineProps, defineEmits, onMounted, nextTick, computed， watch &#125; from &#x27;vue&#x27;import &#123; useStore&#125; from &#x27;vuex&#x27;import myLogo from &#x27;@/components/myLogo&#x27; //引入的组件不需要再注册const store = useStore() //获取vuex商店const userInfo = computed(() =&gt; store.state.userInfo)const props = defineProps(&#123; item: &#123; type: Object, default: null &#125;&#125;)onMounted(() =&gt; &#123; modelA()&#125;)const list = ref(null) // 1. ref底层还是调用的reactiveconst element = ref(null) // 2. ref的另一个用法，添加到元素的ref属性，将元素赋值给这个变量const list2 = reactive(&#123; a: 1, b: 2&#125;)function modelA() &#123; request(&#123; ... &#125;).then(res =&gt; &#123; // 3. js中需要通过.value才能操作数据，template模板中可以直接访问 list.value = res.data; list2.a = res.data.no; // 4. 不能重新给list2赋值，否则会断开响应式 // list2 = &#123; // ... // &#125; &#125;).catch(err =&gt; &#123; &#125;)&#125;// 5. 给父组件传参方式const emit = defineEmits([&#x27;choose&#x27;])function handleClick() &#123; emit(&#x27;choose&#x27;, [arg])&#125;// 6. setup中定义的变量、方法在外部组件不可见，通过defineExpose暴露出去defineExpose(&#123; modelA &#125;) &lt; /script&gt; 生命周期对比123456789101112Vue2--------------vue3beforeCreate -&gt; setup()created -&gt; setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountedactivated -&gt; onActivateddeactivated -&gt; onDeactivatederrorCaptured -&gt; onErrorCaptured vue3注意点 放弃了对ie11的支持（proxy） 不再使用this 删除了onBeforeCreate和onCreated。因为setup总是在创建组件实例时调用 给vue2开了个口子，旧的options api也能用 移除了filter，可以使用function和computed替代 vue3不限制单个根标签 避免写面条式代码 pinia vuex已停止接受新功能，推荐vue3中使用pinia 对于typescript支持更好 移除了mutation使用方法和vuex类似，这里不多介绍了什么是pinia","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue3/"}]},{"title":"es6整理","slug":"es6整理","date":"2022-06-30T01:57:36.000Z","updated":"2022-08-30T08:23:18.645Z","comments":true,"path":"2022/06/30/es6整理/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/06/30/es6%E6%95%B4%E7%90%86/","excerpt":"class类中的方法12345678class Test &#123; constructor() &#123; //... &#125; toString() &#123; //不需要加function关键字 &#125;&#125; 12345//一次向类添加多个方法Object.assign(Test.prototype, &#123; toValue() &#123;&#125;, toValue2() &#123;&#125;&#125;) 类中的方法是定义在原型上面；在实例上调用方法，其实就是调用原型上的方法 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 实例属性的新写法除了在constructor()里面的this上面，也可以定义在类内部的最顶层 123&#123; _count = 0;&#125; 新写法定义的属性是实例对象自身的属性，而不是在原型上 Class表达式123const MyClass = class Me &#123; ...&#125; 这个类的名字是Me, Me只在class的内部可以使用，在class外部只能用MyClass引用 可以写立即执行的class 12345let person = new class &#123; constructor(name) &#123; this.name = name &#125;&#125;(&#x27;name&#x27;) 静态方法 使用static关键字，表示该方法不会被实例继承，而是直接通过类来调用 静态方法中的this指的是类本身 父类的静态方法可被子类继承 静态方法可以从super对象上调用 非静态方法不能使用this关键字访问静态方法 静态属性1234class Foo &#123; static prop1 = 1;&#125;Foo.prop = 1; 私有方法和私有属性私有字段在类声明的构造方法中可被访问（只能在类的内部访问的方法和属性） 定义在类外部，在类内部调用 将方法名命名为一个Symbol 使用#前缀来定义 12345678910class ClassA &#123; #privateField; constructor() &#123; this.#privateField = 1; delete this.#privateField; //语法错误 this.#test = 1; //语法错误 &#125;&#125;const instance = new ClassA()instance.#privateField === 1; //语法错误","text":"class类中的方法12345678class Test &#123; constructor() &#123; //... &#125; toString() &#123; //不需要加function关键字 &#125;&#125; 12345//一次向类添加多个方法Object.assign(Test.prototype, &#123; toValue() &#123;&#125;, toValue2() &#123;&#125;&#125;) 类中的方法是定义在原型上面；在实例上调用方法，其实就是调用原型上的方法 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 实例属性的新写法除了在constructor()里面的this上面，也可以定义在类内部的最顶层 123&#123; _count = 0;&#125; 新写法定义的属性是实例对象自身的属性，而不是在原型上 Class表达式123const MyClass = class Me &#123; ...&#125; 这个类的名字是Me, Me只在class的内部可以使用，在class外部只能用MyClass引用 可以写立即执行的class 12345let person = new class &#123; constructor(name) &#123; this.name = name &#125;&#125;(&#x27;name&#x27;) 静态方法 使用static关键字，表示该方法不会被实例继承，而是直接通过类来调用 静态方法中的this指的是类本身 父类的静态方法可被子类继承 静态方法可以从super对象上调用 非静态方法不能使用this关键字访问静态方法 静态属性1234class Foo &#123; static prop1 = 1;&#125;Foo.prop = 1; 私有方法和私有属性私有字段在类声明的构造方法中可被访问（只能在类的内部访问的方法和属性） 定义在类外部，在类内部调用 将方法名命名为一个Symbol 使用#前缀来定义 12345678910class ClassA &#123; #privateField; constructor() &#123; this.#privateField = 1; delete this.#privateField; //语法错误 this.#test = 1; //语法错误 &#125;&#125;const instance = new ClassA()instance.#privateField === 1; //语法错误","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"前端分享-2022-06-09","slug":"前端分享-2022-06-09","date":"2022-06-06T09:38:36.000Z","updated":"2022-08-30T08:18:13.751Z","comments":true,"path":"2022/06/06/前端分享-2022-06-09/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/06/06/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-06-09/","excerpt":"几个比较实用的git命令12345678910111213141516&lt;!-- 拉取远程代码 --&gt;git fetch --allgit reset --hard origin/master&lt;!-- 暂存 --&gt;git stashgit stash pop&lt;!-- 把一个分支转移到另一个分支 --&gt;git cherry-pick &lt;commitHash&gt;git cherry-pick &lt;id1&gt;..&lt;id2&gt;&lt;!-- 改写上一次提交信息 --&gt;git commit -v --amend&lt;!-- 清除未跟踪的文件 --&gt;git clean -f --d&lt;!-- 清除ignore之前提交的文件 --&gt;git rm -r --cached css分享 小程序css变量123456/* 解决iPhonex 虚拟按键 */padding-bottom: calc(8px + constant(safe-area-inset-bottom));padding-bottom: calc(8px + env(safe-area-inset-bottom));/* css变量 */--loading-grey: #f1f1f1;background-color: var(--loading-grey, red); 骨架屏1234567891011121314@keyframes loading &#123; /* to &#123; background-position-x: -20%; &#125; */ 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 0.6; &#125; 100% &#123; opacity: 1; &#125;&#125; 粘性定位1position: sticky;","text":"几个比较实用的git命令12345678910111213141516&lt;!-- 拉取远程代码 --&gt;git fetch --allgit reset --hard origin/master&lt;!-- 暂存 --&gt;git stashgit stash pop&lt;!-- 把一个分支转移到另一个分支 --&gt;git cherry-pick &lt;commitHash&gt;git cherry-pick &lt;id1&gt;..&lt;id2&gt;&lt;!-- 改写上一次提交信息 --&gt;git commit -v --amend&lt;!-- 清除未跟踪的文件 --&gt;git clean -f --d&lt;!-- 清除ignore之前提交的文件 --&gt;git rm -r --cached css分享 小程序css变量123456/* 解决iPhonex 虚拟按键 */padding-bottom: calc(8px + constant(safe-area-inset-bottom));padding-bottom: calc(8px + env(safe-area-inset-bottom));/* css变量 */--loading-grey: #f1f1f1;background-color: var(--loading-grey, red); 骨架屏1234567891011121314@keyframes loading &#123; /* to &#123; background-position-x: -20%; &#125; */ 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 0.6; &#125; 100% &#123; opacity: 1; &#125;&#125; 粘性定位1position: sticky; 小程序中取高度 scroll-view组件必需给定高度才能触发滑动加载更多 12345678910const windowHeight = uni.getSystemInfoSync().windowHeight;this.scrollHeight = windowHeight;const stickyBar = uni.createSelectorQuery().select(&#x27;.stickyBar&#x27;)stickyBar.boundingClientRect((data) =&gt; &#123; this.scrollHeight -= data.height&#125;).exec()const footerBar = uni.createSelectorQuery().select(&#x27;.footerBar&#x27;)footerBar.boundingClientRect((data) =&gt; &#123; this.scrollHeight -= data.height&#125;).exec() scroll-view组件中fixed定位失效问题 将要定位的元素移到scroll-view组件外 标题栏高度 1234const rect = uni.getMenuButtonBoundingClientRect(); //胶囊const navigation = uni.getSystemInfoSync() //状态栏const statusHeight = navigation.statusBarHeightconst titleBarHeight = (rect.top - statusHeight) * 2 + rect.height; ES6中的默认参数123456const &#123;a=1&#125; = res// 当res中没有a属性或者属性值为undefined，会赋默认值function test(a=1)&#123; console.log(a)&#125;// 当不传参或传undefined，会赋默认值","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"前端分享-2022-04-21","slug":"前端分享-2022-04-21","date":"2022-04-21T03:02:16.000Z","updated":"2022-08-30T08:17:50.758Z","comments":true,"path":"2022/04/21/前端分享-2022-04-21/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/04/21/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-04-21/","excerpt":"word转html标签处理一些内容比较多的文档，如用户协议之类 123456789101112131415161718192021222324from docx import Documentdocument = Document(&#x27;XXXX.docx&#x27;)str = &#x27;&lt;html&gt;&#x27;str += &#x27;&lt;style&gt;.paragraph &#123;text-indent: 30px;&#125;.bold &#123;font-weight: bold;&#125;.underline &#123;text-decoration: underline;&#125;&lt;/style&gt;&#x27;for p in document.paragraphs: str += &#x27;&lt;p class=&quot;paragraph&quot;&gt;&#x27; for n in p.runs: if(n.font.color.rgb): style = &#x27;color:#&#123;&#125;;&#x27;.format(n.font.color.rgb) if(n.bold): classList = &#x27;bold&#x27; if(n.underline): classList = classList + &#x27; underline&#x27; if classList else &#x27;underline&#x27; if(classList): str += &#x27;&lt;span class=&quot;&#123;&#125;&quot; style=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/span&gt;&#x27;.format(classList,style,n.text) else: str += n.text str += &#x27;&lt;/p&gt;&#x27;str += &#x27;&lt;/html&gt;&#x27;f = open(&#x27;XXXX.html&#x27;, &quot;wb&quot;)f.write(bytes(str, &#x27;utf-8&#x27;))f.close()print(&#x27;success&#x27;)","text":"word转html标签处理一些内容比较多的文档，如用户协议之类 123456789101112131415161718192021222324from docx import Documentdocument = Document(&#x27;XXXX.docx&#x27;)str = &#x27;&lt;html&gt;&#x27;str += &#x27;&lt;style&gt;.paragraph &#123;text-indent: 30px;&#125;.bold &#123;font-weight: bold;&#125;.underline &#123;text-decoration: underline;&#125;&lt;/style&gt;&#x27;for p in document.paragraphs: str += &#x27;&lt;p class=&quot;paragraph&quot;&gt;&#x27; for n in p.runs: if(n.font.color.rgb): style = &#x27;color:#&#123;&#125;;&#x27;.format(n.font.color.rgb) if(n.bold): classList = &#x27;bold&#x27; if(n.underline): classList = classList + &#x27; underline&#x27; if classList else &#x27;underline&#x27; if(classList): str += &#x27;&lt;span class=&quot;&#123;&#125;&quot; style=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/span&gt;&#x27;.format(classList,style,n.text) else: str += n.text str += &#x27;&lt;/p&gt;&#x27;str += &#x27;&lt;/html&gt;&#x27;f = open(&#x27;XXXX.html&#x27;, &quot;wb&quot;)f.write(bytes(str, &#x27;utf-8&#x27;))f.close()print(&#x27;success&#x27;) gulp的简单用例 官方介绍：gulp是一个工具包，可帮助您自动化开发工作流程中繁重而耗时的任务。 gulp是工具链、构建工具。可以配合各种插件做js压缩，css压缩，less编译等，可以替代手工实现自动化工作。webpack是文件打包工具，可以把项目的各种js文件、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案。 实现实时scss转wxss根目录下创建gulpfile.js 123456789101112131415161718192021222324252627282930313233343536const gulp = require(&quot;gulp&quot;);const through = require(&quot;through2&quot;);const sass = require(&#x27;gulp-sass&#x27;)(require(&#x27;sass&#x27;));const rename = require(&quot;gulp-rename&quot;);const replace = require(&quot;gulp-replace&quot;);sass.compiler = require(&quot;node-sass&quot;);function scssToCss(filePath) &#123; let destinationPath = filePath.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;) return ( gulp .src(filePath) .pipe(sass().on(&quot;error&quot;, sass.logError)) .pipe(replaceImportCss()) .pipe( rename(function(path) &#123; path.extname = &quot;.wxss&quot;; &#125;) ) .pipe(gulp.dest(destinationPath)) );&#125;let replaceImportCss = () =&gt; &#123; return replace(/url\\((.+\\.css)\\)/g, (match, $1) =&gt; &#123; console.log(match, $1); return `&quot;$&#123;$1&#125;&quot;`; &#125;);&#125;;exports.default = function() &#123; let watcher = gulp.watch([&quot;./**/*.scss&quot;, &quot;!./node_modules/**/*.scss&quot;]); watcher.on(&quot;change&quot;, function (path) &#123; scssToCss(path); &#125;); watcher.on(&quot;unlink&quot;, function(path) &#123; console.log(`File $&#123;path&#125; was removed`); &#125;);&#125;; 将uni-app代码转vue123456789101112131415161718192021222324252627282930313233343536//750rpx=&gt;1080pxfunction convertFile() &#123; var stream = through.obj(function(file, encoding, callback) &#123; if (!file.isBuffer()) &#123; return callback(); &#125; let fileContent = file.contents.toString(&quot;utf8&quot;) || &quot;&quot;; let newFileCon = fileContent.replace(/([\\d.]+)rpx/g, function(match, $1) &#123; return (Number($1) * 1080 / 750).toFixed(2) + &#x27;px&#x27;; &#125;) .replace(/&lt;view([\\s\\S]*?)&gt;/gi, &quot;&lt;div $1&gt;&quot;) .replace(/&lt;\\/\\s?view&gt;/gi, &quot;&lt;/div&gt;&quot;) .replace(/&lt;image([\\s\\S]*?)&gt;/gi, &quot;&lt;img $1&gt;&quot;) .replace(/&lt;\\/\\s?image&gt;/gi, &quot;&quot;) if (newFileCon !== fileContent) &#123; file.contents = Buffer.from(newFileCon); &#125; else &#123; this.emit(&quot;end&quot;); return; &#125; this.push(file); callback(); &#125;); return stream;&#125;function transferVue(filePath) &#123; let destinationPath = filePath.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;) return ( gulp .src(filePath) .pipe(rpx2px()) .pipe(gulp.dest(&#x27;./h5&#x27;)) );&#125; eventEmitter的简单使用方法eventEmitter.js app.js 1234567891011121314151617const EventEmitter = require(&#x27;./utils/eventEmitter.js&#x27;);const eventBus = new EventEmitter();App(&#123; eventBus, onLaunch()&#123; this.getData &#125;, getData()&#123; wx.request(&#123; ..., success(&#123;data&#125;)&#123; this.globalData.loginData = data eventBus.emit(&#x27;afterGetData&#x27;, data) &#125; &#125;) &#125;&#125;) index.js 12345678910111213const app = getApp()Page(&#123; onLoad:function(options)&#123; if(app.globalData.loginData)&#123; this.loginData = app.globalData.loginData &#125;else&#123; app.eventBus.on(&#x27;afterGetData&#x27;,(data)=&gt;&#123; this.loginData = app.globalData.loginData &#125;) &#125; &#125;&#125;)","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"word2html","slug":"word2html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/word2html/"},{"name":"gulp","slug":"gulp","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/gulp/"}]},{"title":"前端分享-2022-03-03","slug":"前端分享-2022-03-03","date":"2022-03-03T03:32:50.000Z","updated":"2022-08-30T08:17:10.876Z","comments":true,"path":"2022/03/03/前端分享-2022-03-03/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/03/03/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-03-03/","excerpt":"运算符 空值合并运算符 1234let a1 = obj.a || 1 //布尔逻辑运算符 (0,&#x27;&#x27;,NaN,null,undefined,false)会转换成falselet a2 = obj.a ? obj.a : 1let a3 = obj.a ?? &#x27;a&#x27; //空值合并运算符 可选链操作符 123let c1 = obj?.c?.c1let c2 = obj?.c?.[0]let c3 = obj?.c?.c2?.() 展开语法 123456789101112131415161718192021// 1、函数调用：test(...list1)// 2、字面量数组构造或字符串：console.log([...list1, &#x27;4&#x27;, ...&#x27;test&#x27;])console.log(...list1)console.log([...new Set(list1)])// &lt;Hello params=&#123;...params&#125;&gt;// 3、构造字面量对象时,进行克隆或者属性拷贝const obj1 = &#123; a: &#123; b: 1, c: undefined, d: function() &#123;&#125;, e: /^\\d&#123;1&#125;/ &#125;&#125;const obj2 = &#123; ...obj1&#125;const obj3 = Object.assign(&#123;&#125;, obj1)const obj4 = JSON.parse(JSON.stringify(obj1)) //&#123;&quot;a&quot;:&#123;&quot;b&quot;:1,&quot;e&quot;:&#123;&#125;&#125;&#125; requestAnimationFrame 屏幕刷新频率：屏幕每秒出现图像的次数。普通笔记本为60Hz 动画原理：计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。 setTimeout：通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是： settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚； settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。 requestAnimationFrame的优势： 由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿 CPU节能，当页面被隐藏或最小化时，setTimeout 仍然在后台执行，requestAnimationFrame会停止渲染 12345678910111213141516171819202122232425262728293031myAnimation(&#123; target, time, inAnimation, afterAnimation&#125;) &#123; let aniId = null let currentNo = 0 const startTime = new Date().getTime() const p = (time * time) / target const render = () =&gt; &#123; const timeRange = new Date().getTime() - startTime; currentNo = timeRange * timeRange / p currentNo = currentNo &gt;= target ? target : currentNo if (inAnimation &amp;&amp; typeof inAnimation === &#x27;function&#x27;) &#123; inAnimation(currentNo) &#125; if (currentNo &lt; target) &#123; aniId = requestAnimationFrame(render) &#125; else &#123; cancelAnimationFrame(aniId) if (afterAnimation &amp;&amp; typeof afterAnimation === &#x27;function&#x27;) &#123; afterAnimation() &#125; &#125; &#125; aniId = requestAnimationFrame(render)&#125;","text":"运算符 空值合并运算符 1234let a1 = obj.a || 1 //布尔逻辑运算符 (0,&#x27;&#x27;,NaN,null,undefined,false)会转换成falselet a2 = obj.a ? obj.a : 1let a3 = obj.a ?? &#x27;a&#x27; //空值合并运算符 可选链操作符 123let c1 = obj?.c?.c1let c2 = obj?.c?.[0]let c3 = obj?.c?.c2?.() 展开语法 123456789101112131415161718192021// 1、函数调用：test(...list1)// 2、字面量数组构造或字符串：console.log([...list1, &#x27;4&#x27;, ...&#x27;test&#x27;])console.log(...list1)console.log([...new Set(list1)])// &lt;Hello params=&#123;...params&#125;&gt;// 3、构造字面量对象时,进行克隆或者属性拷贝const obj1 = &#123; a: &#123; b: 1, c: undefined, d: function() &#123;&#125;, e: /^\\d&#123;1&#125;/ &#125;&#125;const obj2 = &#123; ...obj1&#125;const obj3 = Object.assign(&#123;&#125;, obj1)const obj4 = JSON.parse(JSON.stringify(obj1)) //&#123;&quot;a&quot;:&#123;&quot;b&quot;:1,&quot;e&quot;:&#123;&#125;&#125;&#125; requestAnimationFrame 屏幕刷新频率：屏幕每秒出现图像的次数。普通笔记本为60Hz 动画原理：计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。 setTimeout：通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是： settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚； settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。 requestAnimationFrame的优势： 由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿 CPU节能，当页面被隐藏或最小化时，setTimeout 仍然在后台执行，requestAnimationFrame会停止渲染 12345678910111213141516171819202122232425262728293031myAnimation(&#123; target, time, inAnimation, afterAnimation&#125;) &#123; let aniId = null let currentNo = 0 const startTime = new Date().getTime() const p = (time * time) / target const render = () =&gt; &#123; const timeRange = new Date().getTime() - startTime; currentNo = timeRange * timeRange / p currentNo = currentNo &gt;= target ? target : currentNo if (inAnimation &amp;&amp; typeof inAnimation === &#x27;function&#x27;) &#123; inAnimation(currentNo) &#125; if (currentNo &lt; target) &#123; aniId = requestAnimationFrame(render) &#125; else &#123; cancelAnimationFrame(aniId) if (afterAnimation &amp;&amp; typeof afterAnimation === &#x27;function&#x27;) &#123; afterAnimation() &#125; &#125; &#125; aniId = requestAnimationFrame(render)&#125; 移动端自适应布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector(&#x27;meta[name=&quot;viewport&quot;]&#x27;); var flexibleEl = doc.querySelector(&#x27;meta[name=&quot;flexible&quot;]&#x27;); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; console.warn(&#x27;将根据已有的meta标签来设置缩放比例&#x27;); var match = metaEl.getAttribute(&#x27;content&#x27;).match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute(&#x27;content&#x27;); if (content) &#123; var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute(&#x27;data-dpr&#x27;, dpr); if (!metaEl) &#123; metaEl = doc.createElement(&#x27;meta&#x27;); metaEl.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;); metaEl.setAttribute(&#x27;content&#x27;, &#x27;initial-scale=&#x27; + scale + &#x27;, maximum-scale=&#x27; + scale + &#x27;, minimum-scale=&#x27; + scale + &#x27;, user-scalable=no,viewport-fit=cover&#x27;); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement(&#x27;div&#x27;); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; console.log(metaEl) &#125; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 1080) &#123; width = 1080 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + &#x27;px&#x27;; flexible.rem = win.rem = rem; &#125; win.addEventListener(&#x27;resize&#x27;, function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener(&#x27;pageshow&#x27;, function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === &#x27;complete&#x27;) &#123; doc.body.style.fontSize = 12 * dpr + &#x27;px&#x27;; &#125; else &#123; doc.addEventListener(&#x27;DOMContentLoaded&#x27;, function(e) &#123; doc.body.style.fontSize = 12 * dpr + &#x27;px&#x27;; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === &#x27;string&#x27; &amp;&amp; d.match(/rem$/)) &#123; val += &#x27;px&#x27;; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === &#x27;string&#x27; &amp;&amp; d.match(/px$/)) &#123; val += &#x27;rem&#x27;; &#125; return val; &#125;&#125;)(window, window[&#x27;lib&#x27;] || (window[&#x27;lib&#x27;] = &#123;&#125;)); 创建postcss.config.js 1234567891011121314151617181920212223const autoprefixer = require(&#x27;autoprefixer&#x27;)const pxtorem = require(&#x27;postcss-pxtorem&#x27;)module.exports = (&#123; file&#125;) =&gt; &#123; let rootValue if (file?.dirname?.indexOf?.(&#x27;vant&#x27;) &gt; -1) &#123; rootValue = 37.5 &#125; else &#123; rootValue = 108 &#125; return &#123; plugins: [ autoprefixer(), pxtorem(&#123; rootValue: rootValue, propList: [&#x27;*&#x27;], minPixelValue: 2 &#125;) ] &#125;&#125; vw布局 持续集成（Continuous Integration）/.github/workflows/hexo-deploy.yml 1234567891011121314151617181920name: deploying Hexo project to GitHub pageson: push: branches: - master # master 分支有 push 行为时就触发这个 actionjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master - name: Build and Deploy uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action env: PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名 PUBLISH_REPOSITORY: chenshanshu/chenshanshu.github.io # 公共仓库，格式：GitHub 用户名/仓库名 BRANCH: gh-pages # 分支，填 gh-pages 就行 PUBLISH_DIR: ./public # 部署 public 目录下的文件 参考文献 mdn-运算符","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"js动画","slug":"js动画","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js%E5%8A%A8%E7%94%BB/"}]},{"title":"前端优化-图片懒加载","slug":"前端优化-图片懒加载","date":"2022-01-24T11:05:10.000Z","updated":"2022-10-25T08:11:37.585Z","comments":true,"path":"2022/01/24/前端优化-图片懒加载/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/24/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"图片懒加载jquery插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556;(function ($, window) &#123; function Lazyload() &#123; this.$win = $(window) &#125; Lazyload.prototype = &#123; constructor: Lazyload, init: function () &#123; this.loadedLen = 0 this.getImgs() this.onScroll() this.$win.on(&quot;scroll&quot;, this.debounce(this.onScroll.bind(this))) &#125;, debounce: function (fn, wait) &#123; var first = true; var timer; var gapTime = wait || 50; return function () &#123; if (first) &#123; first = false fn.apply(this, arguments) &#125; else &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, gapTime) &#125; &#125; &#125;, getImgs: function () &#123; this.imgList = $.map($(&#x27;img[data-src]&#x27;).get(), function (i, index) &#123; return $(i) &#125;) &#125;, onScroll: function () &#123; if (this.loadedLen &gt;= this.imgList.length) return var wTop = this.$win.scrollTop(); var wHeight = this.$win.height(); var pageTop = wHeight + wTop $.each(this.imgList, function (index, img) &#123; if (img.loaded) return if (pageTop - img.offset().top +70 &gt; 0) &#123; img.attr(&#x27;src&#x27;, img.attr(&#x27;data-src&#x27;)) img.loaded = true this.loadedLen++ &#125; &#125;.bind(this)) &#125; &#125; $.fn.extend(&#123; lazyLoad: function () &#123; new Lazyload().init() &#125; &#125;)&#125;)(jQuery, window)","text":"图片懒加载jquery插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556;(function ($, window) &#123; function Lazyload() &#123; this.$win = $(window) &#125; Lazyload.prototype = &#123; constructor: Lazyload, init: function () &#123; this.loadedLen = 0 this.getImgs() this.onScroll() this.$win.on(&quot;scroll&quot;, this.debounce(this.onScroll.bind(this))) &#125;, debounce: function (fn, wait) &#123; var first = true; var timer; var gapTime = wait || 50; return function () &#123; if (first) &#123; first = false fn.apply(this, arguments) &#125; else &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, gapTime) &#125; &#125; &#125;, getImgs: function () &#123; this.imgList = $.map($(&#x27;img[data-src]&#x27;).get(), function (i, index) &#123; return $(i) &#125;) &#125;, onScroll: function () &#123; if (this.loadedLen &gt;= this.imgList.length) return var wTop = this.$win.scrollTop(); var wHeight = this.$win.height(); var pageTop = wHeight + wTop $.each(this.imgList, function (index, img) &#123; if (img.loaded) return if (pageTop - img.offset().top +70 &gt; 0) &#123; img.attr(&#x27;src&#x27;, img.attr(&#x27;data-src&#x27;)) img.loaded = true this.loadedLen++ &#125; &#125;.bind(this)) &#125; &#125; $.fn.extend(&#123; lazyLoad: function () &#123; new Lazyload().init() &#125; &#125;)&#125;)(jQuery, window) 使用IntersectionObserver实现懒加载","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"前端优化-缓存篇","slug":"前端优化-缓存篇","date":"2022-01-21T02:31:36.000Z","updated":"2022-01-24T06:37:46.254Z","comments":true,"path":"2022/01/21/前端优化-缓存篇/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/21/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-%E7%BC%93%E5%AD%98%E7%AF%87/","excerpt":"浏览器缓存属于必须掌握的内容，利用好缓存也是做性能优化的有效方法。 为什么要缓存 减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定比从服务器请求更快； 减少网络带宽消耗，降低运营成本； 减少对服务端的请求，降低服务器压力。 缓存读写顺序","text":"浏览器缓存属于必须掌握的内容，利用好缓存也是做性能优化的有效方法。 为什么要缓存 减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定比从服务器请求更快； 减少网络带宽消耗，降低运营成本； 减少对服务端的请求，降低服务器压力。 缓存读写顺序 HTTP缓存返回状态码200和304的区别浏览器缓存有两种：200 OK(from memory/disk cache)和304 Not Modified， 强缓存 协商缓存 缓存存放位置 本地浏览器 本地浏览器 http状态码 200 304 参数 PragmaCache-ControlExpires Etag/If-None-MatchLast-Modifined/If-Modified-Since Ctrl+F5强制刷新F5刷新地址栏回车页面链接跳转新开窗口前进、后退 无效无效有效有效有效有效 无效有效有效有效有效有效 200 OK(from memory/disk cache)这种缓存方式很普遍，大部分网站的静态文件都采用了，表示直接读取客户端缓存，无需再请求服务器。在服务器里设置，比如Nginx配置里会有类的配置： location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 30d;&#125;location ~ .*\\.(js|css)?$&#123;expires 12h;&#125; 这样就可以给静态文件缓存了，除非用户清除缓存或者强制刷新页面，否则会直接从客户端缓存里读取 304 Not Modified304缓存和上面最大的区别是浏览器要向服务器询问一次，如果服务器认为没有内容更新，直接返回304状态码，无需返回body内容，否则服务器返回新的资源 强缓存相关header字段 Expires策略 Expires 是Web服务器响应消息头字段，代表过期时间 Cache-control策略（重点关注）Cache-Control 与 Expires 的作用一致，都是指明当前资源的有效期，只不过 Cache-Control 的选项更多，若同时设置，优先级高于 Expires http协议头Cache-Control各指令及含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息 。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 协商缓存相关的header字段 Last-Modifined/If-Modified-Since Last-Modified/If-Modified-Since要配合Cache-Control使用。 Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次像服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。 Etag/If-None-Match Etag：服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304 参考文章 浏览器专题之缓存篇一文读懂http缓存（超详细）前端缓存详解","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"}]},{"title":"前端questions","slug":"前端-question","date":"2022-01-20T07:35:16.000Z","updated":"2022-02-14T12:04:06.705Z","comments":true,"path":"2022/01/20/前端-question/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/20/%E5%89%8D%E7%AB%AF-question/","excerpt":"定义函数的两种方式123456789// （1）函数表达式var a = function() &#123; console.log(&#x27;函数表达式形式&#x27;)&#125;// （2）函数申明function a() &#123; console.log(&#x27;函数申明形式&#x27;)&#125;a() //函数表达式形式 两种方式的区别：函数申明会提升，可以在定义函数之前调用该函数","text":"定义函数的两种方式123456789// （1）函数表达式var a = function() &#123; console.log(&#x27;函数表达式形式&#x27;)&#125;// （2）函数申明function a() &#123; console.log(&#x27;函数申明形式&#x27;)&#125;a() //函数表达式形式 两种方式的区别：函数申明会提升，可以在定义函数之前调用该函数 1234567function f(x) &#123; console.log(x); var x = 200; console.log(x); &#125;f(a = 100);console.log(a); 浏览器渲染html步骤1、解析html:会按顺序解析，浏览器有专门的html解析器来解析HTML，并在解析的过程中构建DOM树2、构建dom树：它和步骤(1) 是同步进行，可以理解为边解析边构建。3、构建呈现树renderTree：将dom树与css结合，也就是将样式应用到dom节点上4、布局：计算呈现树节点的大小和位置，这一位置是递归进行的。5、绘制：布局完成后，便是将呈现树绘制出来显示在屏幕上。 什么是回流和重绘pc端问题不大，移动端会导致页面卡顿 回流 reflow:当呈现树renderTree中的一部分或全部因为尺寸、布局、隐藏等改变改重新构建，称之为回流。 重绘：当呈现树renderTree中的一部分元素需要更新属性，而属性只会影响外观、风格而不影响布局，比如颜色、字体大小等，则称之为重绘。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"js事件模型","slug":"js事件模型","date":"2022-01-19T07:07:06.000Z","updated":"2022-07-29T03:48:36.932Z","comments":true,"path":"2022/01/19/js事件模型/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/19/js%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/","excerpt":"DOM0级事件模型 DOM0级事件模型是早期事件模型，实现代码如下： 1234&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;&#125;&lt;/script&gt; 特点： 直接在DOM 对象上注册事件 注册多个时后面的事件会覆盖之前的 所有浏览器都兼容 清除事件时直接赋值null DOM2级事件模型标准事件模型事件传播过程1. 事件捕获：事件由`document`一直向下捕捉到目标元素 2. 事件执行：目标对象的事件处理程序执行 3. 事件冒泡：事件从目标元素上升到`document` 所有时间类型都会经历第一阶段，有的事件不会经历第三阶段（submit），一个 DOM 对象可以注册多个相同类型的事件，不会发生覆盖。 事件注册1[object].addEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) 解除事件1[object].removeEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) true/false决定在那个阶段调用函数true: 捕获false: 冒泡 事件对象 停止传播：event.stopPropagation() 阻止默认动作：event.preventDefault() 示例 给一个元素添加两个事件，捕获阶段的事件会先执行，但两个时间戳相同。 1234567var btn = document.getElementById(&#x27;btn__submit&#x27;)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in bubble&#x27;, new Date().getTime())&#125;, false)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in capture&#x27;, new Date().getTime())&#125;, true) 绑定多个事件，并阻止冒泡12345678910btn.addEventListener(&#x27;click&#x27;,function(params) &#123; params.stopPropagation() console.log(1)&#125;,false)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(2)&#125;,true)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(3)&#125;,true) 在冒泡阶段阻止冒泡，在捕获阶段的绑定事件会先执行，三个事件都会触发在捕获阶段阻止冒泡，第一个事件不再触发，后两个触发。","text":"DOM0级事件模型 DOM0级事件模型是早期事件模型，实现代码如下： 1234&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;&#125;&lt;/script&gt; 特点： 直接在DOM 对象上注册事件 注册多个时后面的事件会覆盖之前的 所有浏览器都兼容 清除事件时直接赋值null DOM2级事件模型标准事件模型事件传播过程1. 事件捕获：事件由`document`一直向下捕捉到目标元素 2. 事件执行：目标对象的事件处理程序执行 3. 事件冒泡：事件从目标元素上升到`document` 所有时间类型都会经历第一阶段，有的事件不会经历第三阶段（submit），一个 DOM 对象可以注册多个相同类型的事件，不会发生覆盖。 事件注册1[object].addEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) 解除事件1[object].removeEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) true/false决定在那个阶段调用函数true: 捕获false: 冒泡 事件对象 停止传播：event.stopPropagation() 阻止默认动作：event.preventDefault() 示例 给一个元素添加两个事件，捕获阶段的事件会先执行，但两个时间戳相同。 1234567var btn = document.getElementById(&#x27;btn__submit&#x27;)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in bubble&#x27;, new Date().getTime())&#125;, false)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in capture&#x27;, new Date().getTime())&#125;, true) 绑定多个事件，并阻止冒泡12345678910btn.addEventListener(&#x27;click&#x27;,function(params) &#123; params.stopPropagation() console.log(1)&#125;,false)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(2)&#125;,true)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(3)&#125;,true) 在冒泡阶段阻止冒泡，在捕获阶段的绑定事件会先执行，三个事件都会触发在捕获阶段阻止冒泡，第一个事件不再触发，后两个触发。 IE模型 IE的事件机制没有捕获阶段，事件流是非标准的，只有目标阶段和冒泡阶段。 添加事件：dom.attachEvent() 移除事件：dom.detachEvent() 阻止冒泡：12e = window.event;e.cancelBubble = true; 阻止默认事件1e.returnValue = false; 标准事件模型中，注册函数时，事件类型前不加on,IE中要加on attachEvent注册的函数为全局调用函数，而不是文档元素的方法，因此this引用的是window对象 注册多个处理函数时，标准事件模型中，若注册多个同名函数会被忽略，以第一个为准；在IE中，同一个函数可以被注册多次 DOM3级事件DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下： UI事件，当用户与页面上的元素交互时触发，如：load、scroll、abort、select、error 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 同时DOM3级事件也允许使用者自定义一些事件。 UI事件在DOM2级事件中归为HTML事件，判断浏览器是否支持DOM2级别事件中的HTML事件 1var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;,&quot;2.0&quot;) 判断浏览器是否支持DOM3级事件规定的UI事件： 1var isSupported = document.implementation.hasFeature(&quot;UIEvents&quot;,&quot;3.0&quot;) 自定义事件（Event和CustomEvent） Event Event算是一个顶级接口，CustomEvent基于Event,增加了部分参数 1var event = new Event(typeArg[, eventInit]); eventInit: 参数 介绍 bubbles 可选，Boolean类型，默认值为 false，表示该事件是否冒泡。 cancelable 可选，Boolean类型，默认值为 false， 表示该事件能否被取消。 composed 可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。 example: 12345var evt = new Event(&quot;test&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);document.addEventListener(&#x27;test&#x27;, function () &#123; console.log(&#x27;触发了自定义事件&#x27;)&#125;)document.dispatchEvent(evt); CustomEvent1var event = new CustomEvent(typeArg,customEventInit); customEventInit: 参数 介绍 detail 可选的默认值是 null 的任意类型数据，是一个与 event 相关的值（向事件对象添加更多数据） customEventInit可以接受eventInit字典的参数 以上内容参考了下列文章CSDN:事件模型","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"GithubAction和Webhook使用入门","slug":"GithubAction和Webhook使用入门","date":"2022-01-11T03:12:42.000Z","updated":"2022-08-30T08:20:15.924Z","comments":true,"path":"2022/01/11/GithubAction和Webhook使用入门/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/11/GithubAction%E5%92%8CWebhook%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","excerpt":"什么是Github Action Github Action是Github官方推出的持续集成/部署模块服务(CI/CD)。 它是事件驱动的，而且与Github深度整合，可以运行很多Github事件，除了部署和发布，还可以做很多事情，例如压缩合并css和JavaScript。 什么是Webhook Webhook是一个API概念，术语“网络钩子”，有时也被称为“反向 API”。因为它提供了API规则，Webhook将向你的应用发起http请求。 准确的说Webhook是一种web回调或者http的push API，可以使用Webhook“订阅”活动。 hexo自动打包发布通知流程 本地编写完，通过git提交到Github仓库 Github Action监听到push event事件触发ci.yml执行脚本 build打包生成部署文件推送到目标仓库 设置webhook监听推送事件，执行webhook.sh脚本 将结果进行邮件通知 实现步骤第一步，在github setting-&gt;Developer settings-&gt;Personal access tokens创建新的token，并保存这个值；第二步，进入源代码仓库，Settings-&gt;Secrets里将第一步的token添加进去，SECRET_NAME取名为HEXO_DEPLOY；第三步，新建一个Github仓库，命名为用户名.github.io,启动github-pages,具体可参考官方文档；","text":"什么是Github Action Github Action是Github官方推出的持续集成/部署模块服务(CI/CD)。 它是事件驱动的，而且与Github深度整合，可以运行很多Github事件，除了部署和发布，还可以做很多事情，例如压缩合并css和JavaScript。 什么是Webhook Webhook是一个API概念，术语“网络钩子”，有时也被称为“反向 API”。因为它提供了API规则，Webhook将向你的应用发起http请求。 准确的说Webhook是一种web回调或者http的push API，可以使用Webhook“订阅”活动。 hexo自动打包发布通知流程 本地编写完，通过git提交到Github仓库 Github Action监听到push event事件触发ci.yml执行脚本 build打包生成部署文件推送到目标仓库 设置webhook监听推送事件，执行webhook.sh脚本 将结果进行邮件通知 实现步骤第一步，在github setting-&gt;Developer settings-&gt;Personal access tokens创建新的token，并保存这个值；第二步，进入源代码仓库，Settings-&gt;Secrets里将第一步的token添加进去，SECRET_NAME取名为HEXO_DEPLOY；第三步，新建一个Github仓库，命名为用户名.github.io,启动github-pages,具体可参考官方文档；","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"前端分享 2021/12/31","slug":"前端分享-2021-12-31","date":"2021-12-31T02:16:25.000Z","updated":"2022-08-30T08:16:14.742Z","comments":true,"path":"2021/12/31/前端分享-2021-12-31/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/12/31/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2021-12-31/","excerpt":"reduce()的用法1arr.reduce(callback,[initialValue]) 数组求和 12345var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; return prev + cur; &#125;, 0) 计算一个数组中每个元素出现的次数 123456789let arr = [&#x27;test&#x27;, &#x27;test&#x27;, &#x27;name&#x27;, &#x27;sun&#x27;, &#x27;mon&#x27;, &#x27;wen&#x27;, &#x27;sun&#x27;]let result = arr.reduce((pre, cur) =&gt; &#123; if (cur in pre) &#123; pre[cur]++ &#125; else &#123; pre[cur] = 1 &#125; return pre&#125;, &#123;&#125;) 数组去重 12345let result = arr.reduce((pre, cur) =&gt; &#123; if (!pre.includes(cur)) &#123; pre.push(cur) &#125;&#125;, []) 将多维数组转为一维 123456789let arr = [ [0, 1], [2, 3], [4, [5, 6, 7]]]const newArr = function(arr) &#123; return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])&#125;console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]","text":"reduce()的用法1arr.reduce(callback,[initialValue]) 数组求和 12345var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; return prev + cur; &#125;, 0) 计算一个数组中每个元素出现的次数 123456789let arr = [&#x27;test&#x27;, &#x27;test&#x27;, &#x27;name&#x27;, &#x27;sun&#x27;, &#x27;mon&#x27;, &#x27;wen&#x27;, &#x27;sun&#x27;]let result = arr.reduce((pre, cur) =&gt; &#123; if (cur in pre) &#123; pre[cur]++ &#125; else &#123; pre[cur] = 1 &#125; return pre&#125;, &#123;&#125;) 数组去重 12345let result = arr.reduce((pre, cur) =&gt; &#123; if (!pre.includes(cur)) &#123; pre.push(cur) &#125;&#125;, []) 将多维数组转为一维 123456789let arr = [ [0, 1], [2, 3], [4, [5, 6, 7]]]const newArr = function(arr) &#123; return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])&#125;console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7] Vuex数据保存问题 Vuex存储在内存，数据刷新就会丢失，无内存大小限制，而Storage最大为5M。数据为响应式，用于组件间传值。 sessionStorage 用于临时保存数据，标签页关闭后数据删除 localStorage 可以在多个标签页共享没有过期时间，除非手动删除 question: 移动端页面进行支付时页面会进行刷新, 导致Vuex存储的数据丢失了。 12345678910111213141516171819202122232425const getState = _ =&gt; JSON.parse(window.sessionStorage.getItem(&quot;state&quot;) || &#x27;&#123;&#125;&#x27;)const setState = state =&gt; window.sessionStorage.setItem(&#x27;state&#x27;, JSON.stringify(state || &#123;&#125;));import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; id: null, name: null, ...getState() &#125; mutations: &#123; SETNAME(state, v) &#123; state.name = v &#125; &#125;, actions: &#123; setName(context, val) &#123; context.commit(&quot;SETNAME&quot;, val) setState(context.state) &#125; &#125;, getters: &#123;&#125;&#125;) scrollHeight用法","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/reduce/"},{"name":"vuex","slug":"vuex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vuex/"}]},{"title":"flask-auth","slug":"flask-auth","date":"2021-10-19T07:41:16.000Z","updated":"2022-01-10T02:32:47.981Z","comments":true,"path":"2021/10/19/flask-auth/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/10/19/flask-auth/","excerpt":"一、windows系统python3虚拟环境 新建文件夹venv，然后执行python -m venv venv 运行.\\Scripts\\activate.bat启动虚拟环境cmd中需要使用反斜线，否则无法启动 二、Flask服务12345678910111213141516171819202122from flask import Flask,requestfrom markupsafe import escapeapp = Flask(__name__)#通过route()装饰器来把函数绑定到URL@app.route(&quot;/&quot;)def index(): return &quot;hellow world&quot;#app对象的add_url_rule()函数也可以用于将URL与函数绑定def hello_world(): return &#x27;hello world&#x27;app.add_url_rule(&#x27;/&#x27;,&#x27;hello&#x27;,hello_word)@app.route(&quot;/path/&lt;path:subpath&gt;&quot;)def show_subpath(subpath): return f&#x27;subpath &#123;escape(subpath)&#125;&#x27;if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000) 转换器类型：URL内用中括号标记变量，通过converter:variable_name为变量加上转换器 字段 说明 string （缺省值）接受任何不包含斜杆的文本 int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 URL构建url_for()函数用于构建指定函数的URL, 函数名称作为第一个参数，可接受任意个关键字参数 静态文件只要在您的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) 三、Flask服务启动 安装Flask模块pip install Flask 编写好脚本保存为server.py set FLASK_APP=server 需要打开开发功能set FLASK_ENV=development 运行flask run","text":"一、windows系统python3虚拟环境 新建文件夹venv，然后执行python -m venv venv 运行.\\Scripts\\activate.bat启动虚拟环境cmd中需要使用反斜线，否则无法启动 二、Flask服务12345678910111213141516171819202122from flask import Flask,requestfrom markupsafe import escapeapp = Flask(__name__)#通过route()装饰器来把函数绑定到URL@app.route(&quot;/&quot;)def index(): return &quot;hellow world&quot;#app对象的add_url_rule()函数也可以用于将URL与函数绑定def hello_world(): return &#x27;hello world&#x27;app.add_url_rule(&#x27;/&#x27;,&#x27;hello&#x27;,hello_word)@app.route(&quot;/path/&lt;path:subpath&gt;&quot;)def show_subpath(subpath): return f&#x27;subpath &#123;escape(subpath)&#125;&#x27;if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000) 转换器类型：URL内用中括号标记变量，通过converter:variable_name为变量加上转换器 字段 说明 string （缺省值）接受任何不包含斜杆的文本 int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 URL构建url_for()函数用于构建指定函数的URL, 函数名称作为第一个参数，可接受任意个关键字参数 静态文件只要在您的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) 三、Flask服务启动 安装Flask模块pip install Flask 编写好脚本保存为server.py set FLASK_APP=server 需要打开开发功能set FLASK_ENV=development 运行flask run 四、更多用法4.1、日志调用示例： 123app.logger.debug(&#x27;A value for debugging&#x27;)app.logger.warning(&#x27;A warning occurred (%d apples)&#x27;, 42)app.logger.error(&#x27;An error occurred&#x27;) 4.2、Flask概述什么是Web Framework?Web Application Framework(web应用程序框架)或简单的Web Framework(Web框架)表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。 什么是Flask?Flask是一个用Python编写的Web应用程序框架。Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。 WSGIWeb Server Gateway Interface(Web服务器网关接口，WSGI)已被用作Python Web应用程序开发的标准。WSGI是Web服务器和Web应用程序之间通用接口的规范 Werkzeug它是一个WSGI工具包，它实现了请求，响应对象和实用函数。这使得能够在其上构建Web框架。 jinja2jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。","categories":[{"name":"python","slug":"python","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/python/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/flask/"},{"name":"Oauth","slug":"Oauth","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Oauth/"}]},{"title":"css整理","slug":"css整理","date":"2021-07-28T08:16:10.000Z","updated":"2022-08-30T08:23:36.746Z","comments":true,"path":"2021/07/28/css整理/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/07/28/css%E6%95%B4%E7%90%86/","excerpt":"sticky商品详情页，主图缓动效果 1234position: sticky;top: 0;transform: translateZ(-1px) scale(2);transform-origin: 0 0;","text":"sticky商品详情页，主图缓动效果 1234position: sticky;top: 0;transform: translateZ(-1px) scale(2);transform-origin: 0 0;","categories":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"}]},{"title":"一种避免重复请求的方法","slug":"一种避免重复请求的方法","date":"2021-06-21T11:44:50.000Z","updated":"2022-01-11T03:53:13.810Z","comments":true,"path":"2021/06/21/一种避免重复请求的方法/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/06/21/%E4%B8%80%E7%A7%8D%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"需求1、需求：小程序在app.js中需要发起一个login请求，在index的onLoad()钩子里要拿到login的返回值进行后续操作。2、通过该方法可以避免在第一次请求未完成时发出第二个请求。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 一种避免重复请求的方法,不支持async * @arg * arg[0] id String * arg[1] promise函数 Function * arg[2] arg[1]的参数 Object **/let emiter = &#123;&#125;;export default class Emiter &#123; constructor(...arg) &#123; const unionKey = &#x27;emiter-&#x27; + arg[0] this.emiter = emiter[unionKey] = emiter[unionKey] || &#123; resolveQueue: [], rejectQueue: [] &#125; this.methods = arg[1] || &#x27;&#x27; if (typeof this.methods !== &#x27;function&#x27;) return if (this.emiter.promiseStatus === &#x27;resolved&#x27;) &#123; setTimeout(_ =&gt; &#123; this.emitAll(this.emiter.resolveQueue, this.emiter.res) &#125;) &#125; else if (!this.emiter.promiseStatus) &#123; this.emiter.promiseStatus = &#x27;pending&#x27; this.methods(arg[2] || &#123;&#125;).then(res =&gt; &#123; setTimeout(_ =&gt; &#123; delete this.emiter.promiseStatus &#125;, 1000) this.emiter.promiseStatus = &#x27;resolved&#x27; this.emiter.res = res this.emitAll(this.emiter.resolveQueue, res) &#125;).catch(err =&gt; &#123; delete this.emiter.promiseStatus this.emitAll(this.emiter.rejectQueue, err) &#125;) &#125; &#125; emitAll(queue, res) &#123; if (this.emiter.promiseStatus === &#x27;pending&#x27;) return while (queue.length) &#123; queue[0](res) queue.shift() &#125; &#125; then(callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.resolveQueue.push(callback) &#125; return this &#125; catch (callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.rejectQueue.push(callback) &#125; return this &#125;&#125;","text":"需求1、需求：小程序在app.js中需要发起一个login请求，在index的onLoad()钩子里要拿到login的返回值进行后续操作。2、通过该方法可以避免在第一次请求未完成时发出第二个请求。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 一种避免重复请求的方法,不支持async * @arg * arg[0] id String * arg[1] promise函数 Function * arg[2] arg[1]的参数 Object **/let emiter = &#123;&#125;;export default class Emiter &#123; constructor(...arg) &#123; const unionKey = &#x27;emiter-&#x27; + arg[0] this.emiter = emiter[unionKey] = emiter[unionKey] || &#123; resolveQueue: [], rejectQueue: [] &#125; this.methods = arg[1] || &#x27;&#x27; if (typeof this.methods !== &#x27;function&#x27;) return if (this.emiter.promiseStatus === &#x27;resolved&#x27;) &#123; setTimeout(_ =&gt; &#123; this.emitAll(this.emiter.resolveQueue, this.emiter.res) &#125;) &#125; else if (!this.emiter.promiseStatus) &#123; this.emiter.promiseStatus = &#x27;pending&#x27; this.methods(arg[2] || &#123;&#125;).then(res =&gt; &#123; setTimeout(_ =&gt; &#123; delete this.emiter.promiseStatus &#125;, 1000) this.emiter.promiseStatus = &#x27;resolved&#x27; this.emiter.res = res this.emitAll(this.emiter.resolveQueue, res) &#125;).catch(err =&gt; &#123; delete this.emiter.promiseStatus this.emitAll(this.emiter.rejectQueue, err) &#125;) &#125; &#125; emitAll(queue, res) &#123; if (this.emiter.promiseStatus === &#x27;pending&#x27;) return while (queue.length) &#123; queue[0](res) queue.shift() &#125; &#125; then(callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.resolveQueue.push(callback) &#125; return this &#125; catch (callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.rejectQueue.push(callback) &#125; return this &#125;&#125; 示例1234567const fun = function (params) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(_ =&gt; &#123; resolve(&#x27;REQUEST SUCCESS&#x27;) &#125;, 1000) &#125;)&#125;new Emiter(&#x27;union-id&#x27;, fun).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"浏览器下载文件","slug":"浏览器下载文件","date":"2021-04-23T07:17:35.000Z","updated":"2021-10-20T06:23:23.907Z","comments":true,"path":"2021/04/23/浏览器下载文件/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/04/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/","excerpt":"","text":"文件下载","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"浏览器打印功能","slug":"浏览器打印功能","date":"2021-04-07T02:22:41.000Z","updated":"2022-01-10T04:23:25.722Z","comments":true,"path":"2021/04/07/浏览器打印功能/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD/","excerpt":"打印API：window.print() 需求：打印局部内容，如打印下面页面类名 printBox 里面的内容12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div&gt;页面内容...&lt;/div&gt; &lt;button class=&quot;printBtn&quot;&gt;打印报告&lt;/button&gt; &lt;div id=&quot;printContent&quot; style=&quot;display:none&quot;&gt; &lt;div class=&quot;printBox&quot;&gt; &lt;h1&gt;打印报告&lt;h1&gt; &lt;p&gt;报告内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","text":"打印API：window.print() 需求：打印局部内容，如打印下面页面类名 printBox 里面的内容12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div&gt;页面内容...&lt;/div&gt; &lt;button class=&quot;printBtn&quot;&gt;打印报告&lt;/button&gt; &lt;div id=&quot;printContent&quot; style=&quot;display:none&quot;&gt; &lt;div class=&quot;printBox&quot;&gt; &lt;h1&gt;打印报告&lt;h1&gt; &lt;p&gt;报告内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 实现：已知A4纸张尺寸为297mm*210mm，通过创建 iframe 来实现打印；123456789101112131415161718192021222324252627282930var a = 1;var frameId = &#x27;printFrame&#x27;;/** * @param &#123;boolean&#125; portrait 是否纵向打印*/var print = function(portrait)&#123; var iframe = document.getElementById(frameId); if(!iframe)&#123; var frameStyle = portrait ? `&lt;style&gt;@page&#123;size:A4 portrait;margin:0mm;width:297mm;min-height:200mm;&#125;&lt;/style&gt;`: `&lt;style&gt;@page&#123;size:A4 landscape;margin:0mm;width:210mm;min-height:280mm;&#125;&lt;/style&gt;`; // 当高度设置为最大值，会出现打印内容后面多出一张空白页 var el = document.getElementById(&quot;printContent&quot;); iframe = document.createElement(&#x27;IFRAME&#x27;); iframe.setAttribute(frameId); iframe.setAttribute(&#x27;style&#x27;, &#x27;position:absolute;width:0px;height:0px;left:-500px;top:-500px;&#x27;); document.body.appendChild(iframe); var doc = iframe.contentWindow.document; doc.write(frameStyle); doc.write(`&lt;div&gt;$&#123;el.innerHTML&#125;&lt;/div&gt;`); doc.close(); iframe.contentWindow.focus(); &#125; iframe.contentWindow.print(); if (navigator.userAgent.indexOf(&quot;MSIE&quot;) &gt; 0)&#123; document.body.removeChild(iframe); &#125;&#125; 注意： 当打印内容带有背景时候记得勾选背景图形选项 此处只测试了Chrome，兼容性未处理 扩展：打印机型号不同时打印内容也有差别，所以可以通过用canvas来绘制内容(可以参考微信小程序生成分享图功能)，然后生成图片放入第二步的iframe中。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"Web Components","slug":"web-components","date":"2020-11-06T02:10:29.000Z","updated":"2022-08-30T08:09:13.698Z","comments":true,"path":"2020/11/06/web-components/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/11/06/web-components/","excerpt":"","text":"The Shadow DOM通过shadow DOM在文档流中创建一些完全独立于其他元素的子DOM树（sub-DOM trees），由于这个特性，使我们能封装一个具有独立功能的组件，并且可以保证不会干扰到其它DOM元素 兼容性Chrome、Opera、Chrome for Android WebComponents的重要性 开发无害插件（主页面样式不会修改组件样式） 能开发更通用的组件 可维护","categories":[{"name":"html5","slug":"html5","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/html5/"}],"tags":[{"name":"web","slug":"web","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/web/"}]},{"title":"Apache配置","slug":"Apache配置","date":"2020-10-28T07:40:04.000Z","updated":"2021-03-04T06:49:48.057Z","comments":true,"path":"2020/10/28/Apache配置/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/Apache%E9%85%8D%E7%BD%AE/","excerpt":"","text":"wamp安装及配置反向代理 安装wamp，也可安装apache 下载地址 “http://www.wampserver.com/en/&quot; 配置apache使外网访问（版本2.4.27） 修改httpd.conf文件Require all denied ==&gt; Require all granted Require local ==&gt; Require all granted Listen 0.0.0.0:8000 //搜索 Listen 0.0.0.0:80 添加对8000端口的监听 修改httpd-vhosts.conf文件Require all denied ==&gt; Require all granted //至此别人可以访问你的www目录下的静态内容 设置花生壳内网穿透（有公网ip的忽略） 填写你的局域网ip,端口,获得外网访问地址 配置Apache反向代理nodejs服务 修改httpd.conf文件 //去掉下列内容的注释，引入代理模块 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so //如需ftp，取消如下注释 LoadModule proxy_ftp_module modules/mod_proxy_ftp.so 修改httpd-vhosts.conf文件 //添加下列代码 &lt;VirtualHost *:8000&gt; //不放在80端口上防止影响phpMyAdmin ServerName 20xr498049.imwork.net //外网访问的域名 ServerAlias www.20xr498049.imwork.net:42685 //别名 #DocumentRoot &quot;$&#123;INSTALL_DIR&#125;/www&quot; &lt;Proxy *&gt; Order allow,deny Allow from all &lt;/Proxy&gt; &lt;Location /&gt; ProxyPass http://localhost:3000/ //node访问地址 ProxyPassReverse http://localhost:3000/ &lt;/Location&gt; &lt;/VirtualHost&gt; 开启nodejs项目，重启apache服务。","categories":[],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Apache/"}]},{"title":"git 手册","slug":"git-手册","date":"2020-10-28T07:34:41.000Z","updated":"2022-08-30T08:19:50.685Z","comments":true,"path":"2020/10/28/git-手册/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/git-%E6%89%8B%E5%86%8C/","excerpt":"git操作 分支操作 操作 命令 新建本地新分支 git branch branch 新建并切换到本地新分支 git checkout -b branch 新建远程分支 git push origin branch:remoteBranch 删除本地分支 git branch -d dev 删除远程分支 git push origin :remoteBranch 设置本地追踪远程分支 git branch --set-upstream-to=origin/remoteBranch localBranch 直接将远程分支拉取并在本地建立关联分支 git checkout -b localBranch origin/remoteBranch orgit fetch origin master:test 强制操作 操作 命令 强制覆盖本地修改 git fetch --allgit reset --hard origin/mastergit pull 强制上传 git push -f origin remoteBranch 版本管理 操作 命令 查看本地分支与远程关联情况 git branch -vv 查看本地仓库状态 git status 查看本地操作 git reflog 比较本地与远程 git log -p master ..origin/master 查看某个提交 git show commitID 修改主机地址 git remote set-url origin ssh.aaaa.gitorgit remote rm origingit remote add origin [url] 版本回退 git reset --hard commitID 版本回滚 git revert HEAD 将指定的提交（commit）应用于其他分支 git cherry-pick commitID//分支名 Cherry pick 支持一次转移多个提交 git cherry-pick A^..B//包含A和B","text":"git操作 分支操作 操作 命令 新建本地新分支 git branch branch 新建并切换到本地新分支 git checkout -b branch 新建远程分支 git push origin branch:remoteBranch 删除本地分支 git branch -d dev 删除远程分支 git push origin :remoteBranch 设置本地追踪远程分支 git branch --set-upstream-to=origin/remoteBranch localBranch 直接将远程分支拉取并在本地建立关联分支 git checkout -b localBranch origin/remoteBranch orgit fetch origin master:test 强制操作 操作 命令 强制覆盖本地修改 git fetch --allgit reset --hard origin/mastergit pull 强制上传 git push -f origin remoteBranch 版本管理 操作 命令 查看本地分支与远程关联情况 git branch -vv 查看本地仓库状态 git status 查看本地操作 git reflog 比较本地与远程 git log -p master ..origin/master 查看某个提交 git show commitID 修改主机地址 git remote set-url origin ssh.aaaa.gitorgit remote rm origingit remote add origin [url] 版本回退 git reset --hard commitID 版本回滚 git revert HEAD 将指定的提交（commit）应用于其他分支 git cherry-pick commitID//分支名 Cherry pick 支持一次转移多个提交 git cherry-pick A^..B//包含A和B","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"linux 笔记","slug":"linux-shell笔记","date":"2020-10-28T07:28:10.000Z","updated":"2022-08-30T08:12:01.128Z","comments":true,"path":"2020/10/28/linux-shell笔记/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/linux-shell%E7%AC%94%E8%AE%B0/","excerpt":"几个常用命令","text":"几个常用命令 raspberry 安装nginx sudo apt-get install nginx sudo /etc/init.d/nginx start 启动 curl -I localhost:80 测试能否访问 sudo nano /etc/nginx/sites-available/default 修改端口 sudo /etc/init.d/nginx reload 重启 用户操作 useradd chenss 添加用户 userdel chenss 删除用户 usermod -a -G user chenss 添加用户组 usermod -g user chenss 修改用户主组 newgrp root 切换用户主从组 groupadd groupname 添加组 groupmod -n new_name： 修改组名 groupdel groupname 删除组 groupmems -g groupname [action] /* -a, –add username: 指定用户加入组；-d, –delete username: 从组中删除用户；-p, –purge : 从组中清除所有成员；-l, –list: 显示组成员列表; */ gpasswd -a chenss user 给组添加用户 gpasswd -d chenss user 删除组中用户 主要配置文件 /etc/passwd: 用户及其属性信息(名称，UID, 主组ID) /etc/shadow: 用户密码及相关属性。 /etc/group: 组及其属性信息。 /etc/gshadow: 组密码及相关属性。 /etc/wpa_supplicant/wpa_supplicant.conf: WiFi管理 redesktop使用文档 apt-get install redesktop ctrl+alt+t //打开终端 rdesktop -f -a 32 -u username -p password ip:port //-f 全屏 ctrl+alt+enter //切换全屏 ctrl+alt+F2 //进入字符终端杀死进程 sudo pkill rdesktop","categories":[{"name":"linux","slug":"linux","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/shell/"}]},{"title":"快速上手webpack","slug":"快速上手webpack","date":"2020-10-28T07:25:23.000Z","updated":"2022-11-28T08:21:20.266Z","comments":true,"path":"2020/10/28/快速上手webpack/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bwebpack/","excerpt":"","text":"概念 webpack是一个前端资源加载/打包工具。 它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 安装需要先安装好nodejs, 然后执行下列操作；可能遇到的问题，linux下通过sudo获得管理员权限安装，windows下开始搜索cmd, 右键以管理员身份运行才能安装以下内容；但是在vscode、webstorm等控制台可以直接安装。 mkdir webpacktest cd webpacktest npm init -f-y npm i webpack -D /*i == install ; -D == --dev--save ; */ npm i webpack-cli -D /*webpack4提示需要安装这个才能使用*/ 使用安装后webpack模块就被安装到项目里的node_modules文件夹下面；新建文件demo1.js，写入你想执行的js代码。 网上大部分教程都是在linux下的执行命令，这里讲一下windows下的使用方法。 .\\node_modules\\.bin\\webpack demo1.js -o bundle.js --mode development 至此完成了第一次的代码打包。 使用配置文件在项目根目录下新建webpack.config.js；新建src文件夹，以后自己编写的代码全部放在这个文件夹下面；新建dist文件夹用来存放打包后的文件。 const path = require('path'); const config = &#123; mode:'development', entry:&#123; main:path.resolve(__dirname,\"./src\",\"index.js\") &#125;, output:&#123; path:path.resolve(__dirname,'dist'), filename:'bundle.js' &#125;, module:&#123; rules:[ &#123; test:/\\.css$/, use:[ \"style-loader\", \"css-loader\" ] &#125; ] &#125; &#125;; module.exports = config; 有了配置文件后可以用以下命令就能执行打包了 .\\node_modules\\.bin\\webpack 使用起来还是不方便，可以把命令加到package.json里；注意这里只需要提供包名，node会自动找到包所在目录。 \"scripts\": &#123; \"start\": \"webpack\", &#125; 现在可以在命令行使用下面命令打包 npm start /*注意，当命令指定的为start时候可以省去run*/ markdown预览 ctrl+shift+v","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/webpack/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-10-28T02:58:34.000Z","updated":"2022-03-07T02:31:51.083Z","comments":true,"path":"2020/10/28/正则表达式/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"^((?!\\d*$)\\S{2, })|(\\d{6, })$//超过2个字符或者超过6位纯数字 匹配某个变量123var ch = &#x27;变量&#x27;eval(`/$&#123;ch&#125;/g`)new RegExp(ch,&#x27;g&#x27;)","categories":[{"name":"regex","slug":"regex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/regex/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"vue组件的三种调用方式","slug":"vue组件的三种调用方式","date":"2020-06-04T07:37:56.000Z","updated":"2022-08-30T08:13:27.804Z","comments":true,"path":"2020/06/04/vue组件的三种调用方式/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/06/04/vue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、注册组件，直接调用这种比较常见 1234567891011121314&lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;my-dialog /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import MyDialog from &#x27;@/components&#x27; export default &#123; components: &#123; &#x27;my-dialog&#x27;: MyDialog &#125; &#125;&lt;/script&gt; 二、通过js调用使用场景：登陆弹窗，付费弹窗 123456789101112131415161718192021222324252627282930313233343536373839import VipPop from &#x27;./VipPop&#x27;class VipPopup &#123; constructor(Vue, options) &#123; this.vipPop = Vue.extend(VipPop); this.popupInstance = new this.vipPop(&#123; data() &#123; return &#123; title: &#x27;成为VIP，开启新特权&#x27; &#125; &#125;, propsData: &#123;&#125;, extends: options &#125;).$mount(); &#125; show(obj) &#123; obj.title &amp;&amp; (this.popupInstance.title = obj.title); if (this.el) &#123; this.el.style.display = &#x27;block&#x27;; &#125; else &#123; this.el = this.popupInstance.$el; document.body.appendChild(this.el) &#125; document.body.classList.add(&#x27;van-overflow-hidden&#x27;) &#125; hide() &#123; document.body.classList.remove(&#x27;van-overflow-hidden&#x27;) this.el &amp;&amp; (this.el.style.display = &#x27;none&#x27;); &#125; remove() &#123; document.body.classList.remove(&#x27;van-overflow-hidden&#x27;) this.el &amp;&amp; this.el.remove(); this.el = null; &#125; export default &#123; install: function(Vue, options) &#123; Vue.prototype.$vipPop = new VipPopup(Vue, options); &#125; &#125;;&#125; 1234.van-overflow-hidden &#123; overflow: hidden !important; /**禁止背景滚动条**/&#125; 在main.js中引入这个组件 12345678import Vue from &#x27;vue&#x27;import router from &quot;./router.js&quot;import store from &#x27;./store&#x27;import VipPop from &#x27;@/components/VipPop&#x27;Vue.use(VipPop, &#123; router, store&#125;) 三、以指令的形式调用使用场景：加载动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import Vue from &#x27;vue&#x27;const LoadingConstructor = Vue.extend(require(&#x27;./Loading.vue&#x27;))export default &#123; install: Vue =&gt; &#123; Vue.directive(&#x27;loading&#x27;, &#123; // 指令的关键 bind: (el, binding) =&gt; &#123; const loading = new LoadingConstructor(&#123; // 实例化一个loading el: document.createElement(&#x27;div&#x27;), data: &#123; text: el.getAttribute(&#x27;loading-text&#x27;), // 通过loading-text属性获取loading的文字 fullscreen: !!binding.modifiers.fullscreen &#125; &#125;) el.instance = loading; // el.instance是个Vue实例 el.loading = loading.$el; // el.loading的DOM元素是loading.$el el.loadingStyle = &#123;&#125;; toggleLoading(el, binding); &#125;, update: (el, binding) =&gt; &#123; el.instance.setText(el.getAttribute(&#x27;loading-text&#x27;)) if (binding.oldValue !== binding.value) &#123; toggleLoading(el, binding) &#125; &#125;, unbind: (el, binding) =&gt; &#123; // 解绑 if (el.domInserted) &#123; if (binding.modifiers.fullscreen) &#123; document.body.removeChild(el.loading); &#125; else &#123; el.loading &amp;&amp; el.loading.parentNode &amp;&amp; el.loading.parentNode.removeChild(el.loading); &#125; &#125; &#125; &#125;) const toggleLoading = (el, binding) =&gt; &#123; // 用于控制Loading的出现与消失 if (binding.value) &#123; Vue.nextTick(() =&gt; &#123; if (binding.modifiers.fullscreen) &#123; // 如果是全屏 el.originalPosition = document.body.style.position; el.originalOverflow = document.body.style.overflow; insertDom(document.body, el, binding); // 插入dom &#125; else &#123; el.originalPosition = el.style.position; insertDom(el, el, binding); // 如果非全屏，插入元素自身 &#125; &#125;) &#125; else &#123; if (el.domVisible) &#123; el.instance.$on(&#x27;after-leave&#x27;, () =&gt; &#123; el.domVisible = false; if (binding.modifiers.fullscreen &amp;&amp; el.originalOverflow !== &#x27;hidden&#x27;) &#123; document.body.style.overflow = el.originalOverflow; &#125; if (binding.modifiers.fullscreen) &#123; document.body.style.position = el.originalPosition; &#125; else &#123; el.style.position = el.originalPosition; &#125; &#125;); el.instance.visible = false; &#125; &#125; &#125; const insertDom = (parent, el, binding) =&gt; &#123; // 插入dom的逻辑 if (!el.domVisible) &#123; Object.keys(el.loadingStyle).forEach(property =&gt; &#123; el.loading.style[property] = el.loadingStyle[property]; &#125;); if (el.originalPosition !== &#x27;absolute&#x27;) &#123; parent.style.position = &#x27;relative&#x27; &#125; if (binding.modifiers.fullscreen) &#123; parent.style.overflow = &#x27;hidden&#x27; &#125; el.domVisible = true; parent.appendChild(el.loading) // 插入的是el.loading而不是el本身 Vue.nextTick(() =&gt; &#123; el.instance.visible = true; &#125;); el.domInserted = true; &#125; &#125; &#125;&#125; 1&lt;div v-loading.fullscreen=&quot;loading&quot; loading-text=&quot;正在加载中&quot;&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue/"}]},{"title":"文字超出固定行数隐藏","slug":"js实现文字超出固定行数隐藏","date":"2020-06-04T03:19:05.000Z","updated":"2022-08-30T08:14:50.523Z","comments":true,"path":"2020/06/04/js实现文字超出固定行数隐藏/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/06/04/js%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E5%9B%BA%E5%AE%9A%E8%A1%8C%E6%95%B0%E9%9A%90%E8%97%8F/","excerpt":"实现效果","text":"实现效果 实现超出单行隐藏123456.text &#123; width: 300px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; 实现超出三行隐藏12345678.text &#123; width: 300px; overflow: hidden; display: -webkit-box; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 3;&#125; 判断是否有隐藏内容12let dom = document.querySelect(&#x27;.text&#x27;);return dom.scrollHeight &gt; dom.clientHeight;","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-28T07:25:23.000Z","updated":"2022-01-18T02:22:12.309Z","comments":true,"path":"2018/10/28/hello-world/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2018/10/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"},{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"name":"问题","slug":"问题","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E9%97%AE%E9%A2%98/"},{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"},{"name":"工具","slug":"工具","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/python/"},{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/css/"},{"name":"html5","slug":"html5","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/html5/"},{"name":"linux","slug":"linux","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/linux/"},{"name":"regex","slug":"regex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/regex/"},{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/vue/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E8%B0%83%E8%AF%95/"},{"name":"Rollup","slug":"Rollup","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Rollup/"},{"name":"npm","slug":"npm","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/npm/"},{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"},{"name":"cli","slug":"cli","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/cli/"},{"name":"node","slug":"node","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/node/"},{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"},{"name":"vue3","slug":"vue3","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue3/"},{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"},{"name":"word2html","slug":"word2html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/word2html/"},{"name":"gulp","slug":"gulp","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/gulp/"},{"name":"js动画","slug":"js动画","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js%E5%8A%A8%E7%94%BB/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"},{"name":"reduce","slug":"reduce","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/reduce/"},{"name":"vuex","slug":"vuex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vuex/"},{"name":"flask","slug":"flask","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/flask/"},{"name":"Oauth","slug":"Oauth","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Oauth/"},{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"},{"name":"web","slug":"web","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/web/"},{"name":"Apache","slug":"Apache","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Apache/"},{"name":"shell","slug":"shell","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/shell/"},{"name":"webpack","slug":"webpack","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/webpack/"},{"name":"正则","slug":"正则","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%AD%A3%E5%88%99/"},{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue/"}]}